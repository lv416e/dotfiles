#!/usr/bin/env bash
# =============================================================================
# promptq - Prompt Queue Manager for Claude Code
# =============================================================================
# A lightweight JSONL-based queue system for managing and sending prompts
# to Claude Code via tmux send-keys or clipboard.
#
# Usage:
#   promptq add "question text" [#tag1 #tag2]  - Add prompt to queue
#   promptq list                                - List all queued prompts
#   promptq count                               - Show queue size
#   promptq send                                - Send first prompt (FIFO)
#   promptq select-send                         - Interactive send with fzf
#   promptq clear                               - Clear all queued prompts
#   promptq help                                - Show this help
#
# Queue Format (JSONL):
#   {"ts":"2025-10-26T15:00:00+09:00","text":"Question","tags":["tag1"]}
#
# Send Priority:
#   1. tmux send-keys (if Claude detected in tmux pane)
#   2. Clipboard copy (pbcopy) with notification
#   3. Manual fallback with printed prompt
# =============================================================================

set -euo pipefail

# Configuration
readonly Q_DIR="${HOME}/.config/promptq"
readonly QUEUE="${Q_DIR}/queue.jsonl"
readonly SENT="${Q_DIR}/sent.jsonl"
readonly TEMPLATES="${Q_DIR}/templates"
readonly SNIPPETS="${Q_DIR}/snippets"
readonly CONFIG="${Q_DIR}/config"
readonly VERSION="0.1.0"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly RESET='\033[0m'

# =============================================================================
# Modern Rendering System
# =============================================================================

# Global flag for plain output (no styling)
PLAIN_OUTPUT="${PLAIN_OUTPUT:-0}"

# Check if gum is available (respects PLAIN_OUTPUT flag)
has_gum() {
  [[ "$PLAIN_OUTPUT" == "0" ]] && command -v gum >/dev/null 2>&1
}

# Render bordered header
# Usage: render_header "text" ["icon"]
render_header() {
  local text="$1"
  local icon="${2:-📋}"
  local display="$icon $text"

  if has_gum; then
    gum style \
      --foreground 57 \
      --border-foreground 57 \
      --border rounded \
      --padding "0 2" \
      --bold \
      "$display"
  else
    # Fallback: Unicode box drawing
    local len=${#display}
    local border_len=$((len + 4))

    printf "╭"
    printf '─%.0s' $(seq 1 $border_len)
    printf "╮\n"

    printf "│  %s  │\n" "$display"

    printf "╰"
    printf '─%.0s' $(seq 1 $border_len)
    printf "╯\n"
  fi
  echo ""  # Empty line after header
}

# Render table from pipe-delimited data
# Usage: echo "header|data" | render_table
render_table() {
  if has_gum; then
    gum table \
      --separator "|" \
      --border rounded \
      --border.foreground 240 \
      --print
  else
    # Fallback: column command with simpler formatting
    local lines=()
    while IFS= read -r line; do
      lines+=("$line")
    done

    # Format all lines with column first
    local formatted
    formatted=$(printf '%s\n' "${lines[@]}" | column -t -s "|")

    # Print with separator after header
    local idx=0
    while IFS= read -r line; do
      if [[ $idx -eq 0 ]]; then
        # Header line
        echo " $line"
        # Generate separator line (simple dashes)
        local len=${#line}
        printf " "
        printf '─%.0s' $(seq 1 $len)
        echo ""
      else
        # Data lines
        echo " $line"
      fi
      ((idx++))
    done <<< "$formatted"
  fi
}

# Format timestamp as relative time
# Usage: relative_time "2025-10-27T10:30:00+0900"
relative_time() {
  local ts="$1"
  local now=$(date +%s)

  # Try to parse timestamp (macOS date format)
  local then
  then=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "$ts" +%s 2>/dev/null || echo "$now")

  local diff=$((now - then))

  if [ $diff -lt 0 ]; then
    echo "Just now"
  elif [ $diff -lt 60 ]; then
    echo "Just now"
  elif [ $diff -lt 3600 ]; then
    local mins=$((diff / 60))
    echo "${mins}m ago"
  elif [ $diff -lt 86400 ]; then
    local hours=$((diff / 3600))
    echo "${hours}h ago"
  elif [ $diff -lt 604800 ]; then
    local days=$((diff / 86400))
    if [ $days -eq 1 ]; then
      echo "Yesterday"
    else
      echo "${days}d ago"
    fi
  else
    # More than a week: show date
    date -j -f "%Y-%m-%dT%H:%M:%S%z" "$ts" "+%Y-%m-%d" 2>/dev/null || echo "$ts"
  fi
}

# Style text with color
# Usage: style_text "212" "text"
style_text() {
  local color="$1"
  local text="$2"

  if has_gum; then
    gum style --foreground "$color" "$text"
  else
    # Fallback: Use existing color codes
    case "$color" in
      212|magenta) echo -e "${MAGENTA}${text}${RESET}" ;;
      57|blue) echo -e "${BLUE}${text}${RESET}" ;;
      99|cyan) echo -e "${CYAN}${text}${RESET}" ;;
      240|gray) echo -e "${text}" ;;  # No gray in basic ANSI
      *) echo "$text" ;;
    esac
  fi
}

# =============================================================================
# Utility Functions
# =============================================================================

# Print colored message
msg() {
  local color="$1"
  shift
  echo -e "${color}${*}${RESET}"
}

# Print error and exit
die() {
  msg "$RED" "❌ Error: $*" >&2
  exit 1
}

# Ensure config directory and queue file exist
ensure_config() {
  mkdir -p "$Q_DIR"
  touch "$QUEUE" "$SENT"
}

# Get ISO 8601 timestamp with timezone
timestamp() {
  date +"%Y-%m-%dT%H:%M:%S%z"
}

# =============================================================================
# Queue Management Functions
# =============================================================================

# Add prompt to queue
# Usage: add_prompt "text" ["#tag1 #tag2"]
add_prompt() {
  ensure_config

  local text="$1"
  local tags="${2:-}"

  if [[ -z "$text" ]]; then
    die "Prompt text cannot be empty"
  fi

  # Extract tags (words starting with #)
  local tag_array="[]"
  if [[ -n "$tags" ]]; then
    # Convert "#tag1 #tag2" to ["tag1","tag2"]
    tag_array=$(echo "$tags" | grep -oE '#[a-zA-Z0-9_-]+' | sed 's/#//g' | jq -R -s -c 'split("\n") | map(select(length > 0))')
  fi

  # Create JSON entry using jq for safe escaping (compact format)
  local entry
  entry=$(jq -n -c \
    --arg ts "$(timestamp)" \
    --arg text "$text" \
    --argjson tags "$tag_array" \
    '{ts: $ts, text: $text, tags: $tags}')

  echo "$entry" >> "$QUEUE"
  msg "$GREEN" "✅ Added to queue ($(count_queue) items)"
}

# List all queued prompts
list_queue() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    render_header "Queue is empty" "📭"
    return 0
  fi

  render_header "Prompt Queue • $count items" "📋"

  # Build table data
  {
    echo "#|Prompt|Tags|Added"

    local idx=1
    while IFS= read -r line; do
      local text tags ts rel_time
      text=$(echo "$line" | jq -r '.text')
      tags=$(echo "$line" | jq -r '.tags | join(" #")' | sed 's/^/#/')
      ts=$(echo "$line" | jq -r '.ts')

      # Replace newlines with spaces for single-line display
      text=$(echo "$text" | tr '\n' ' ' | tr -s ' ')

      # Truncate long text for table
      if [[ ${#text} -gt 35 ]]; then
        text="${text:0:32}..."
      fi

      # Clean up tags display
      if [[ "$tags" == "#" ]]; then
        tags=""
      fi

      # Get relative time
      rel_time=$(relative_time "$ts")

      echo "$idx|$text|$tags|$rel_time"
      ((idx++))
    done < "$QUEUE"
  } | render_table
}

# Count queued prompts
count_queue() {
  ensure_config
  wc -l < "$QUEUE" | tr -d ' '
}

# Clear all queued prompts
clear_queue() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "📭 Queue is already empty"
    return 0
  fi

  # Backup to sent log before clearing
  if [[ -s "$QUEUE" ]]; then
    cat "$QUEUE" >> "$SENT"
  fi

  > "$QUEUE"
  msg "$GREEN" "✅ Cleared $count items from queue"
}

# Filter queue by tag
filter_by_tag() {
  ensure_config

  local tag="$1"
  # Remove # prefix if present
  tag="${tag#\#}"

  if [[ -z "$tag" ]]; then
    die "Usage: promptq filter #tag"
  fi

  local count=0
  local idx=1

  msg "$CYAN" "📋 Prompts tagged with #${tag}:"
  echo ""

  while IFS= read -r line; do
    local tags_array
    tags_array=$(echo "$line" | jq -r '.tags[]' 2>/dev/null)

    # Check if tag exists in array
    if echo "$tags_array" | grep -qx "$tag"; then
      local text
      text=$(echo "$line" | jq -r '.text')
      local all_tags
      all_tags=$(echo "$line" | jq -r '.tags | join(" #")' | sed 's/^/#/')

      # Replace newlines with spaces for single-line display
      text=$(echo "$text" | tr '\n' ' ' | tr -s ' ')

      # Truncate long text
      if [[ ${#text} -gt 80 ]]; then
        text="${text:0:77}..."
      fi

      printf "${BLUE}%2d${RESET}. %s ${MAGENTA}%s${RESET}\n" "$idx" "$text" "$all_tags"
      ((count++))
    fi
    ((idx++))
  done < "$QUEUE"

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "No prompts found with tag #${tag}"
  fi
}

# List all unique tags
list_tags() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    render_header "No tags yet" "🏷️"
    return 0
  fi

  render_header "Tags in Queue" "🏷️"

  # Build table data
  {
    echo "Tag|Count"

    # Extract all tags, sort, and count occurrences
    jq -r '.tags[]' "$QUEUE" 2>/dev/null | sort | uniq -c | sort -rn | while read -r cnt tag; do
      echo "#$tag|$cnt"
    done
  } | render_table
}

# =============================================================================
# Template Functions
# =============================================================================

# List available templates
list_templates() {
  ensure_config
  mkdir -p "$TEMPLATES"

  if [[ ! -d "$TEMPLATES" ]] || [[ -z "$(ls -A "$TEMPLATES" 2>/dev/null)" ]]; then
    msg "$YELLOW" "📝 No templates found in $TEMPLATES"
    msg "$BLUE" "Create templates with .tmpl extension and use ${VARIABLE} for substitution"
    return 0
  fi

  msg "$CYAN" "📝 Available templates:"
  echo ""

  for template in "$TEMPLATES"/*.tmpl; do
    if [[ -f "$template" ]]; then
      local name
      name=$(basename "$template" .tmpl)

      # Extract variables from template
      local vars
      vars=$(grep -oE '\$\{[A-Z_]+\}' "$template" 2>/dev/null | sort -u | sed 's/\${\(.*\)}/\1/' | tr '\n' ' ' || echo "")

      printf "${GREEN}%-20s${RESET} " "$name"
      if [[ -n "$vars" ]]; then
        printf "${BLUE}Variables: ${YELLOW}%s${RESET}\n" "$vars"
      else
        echo ""
      fi
    fi
  done
}

# Show template content
show_template() {
  local name="$1"

  if [[ -z "$name" ]]; then
    die "Usage: promptq template show <name>"
  fi

  local template_file="${TEMPLATES}/${name}.tmpl"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $name"
  fi

  msg "$CYAN" "📝 Template: $name"
  echo ""
  cat "$template_file"
}

# Add prompt from template
add_from_template() {
  local name="$1"
  shift

  if [[ -z "$name" ]]; then
    die "Usage: promptq template add <name> [VAR=value ...]"
  fi

  local template_file="${TEMPLATES}/${name}.tmpl"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $name"
  fi

  # Read template content
  local content
  content=$(cat "$template_file")

  # Parse and substitute variables directly
  for arg in "$@"; do
    if [[ "$arg" =~ ^([A-Z_]+)=(.*)$ ]]; then
      local var="${BASH_REMATCH[1]}"
      local val="${BASH_REMATCH[2]}"
      # Replace all occurrences of ${VAR} with value
      content="${content//\$\{${var}\}/${val}}"
    fi
  done

  # Check for unsubstituted variables
  if echo "$content" | grep -qE '\$\{[A-Z_]+\}'; then
    local missing
    missing=$(echo "$content" | grep -oE '\$\{[A-Z_]+\}' | sort -u | tr '\n' ' ')
    msg "$RED" "⚠️  Missing required variables: $missing"
    msg "$YELLOW" "Example: promptq template add $name VAR=value"
    return 1
  fi

  # Extract tags from the last line if it starts with #
  local text="$content"
  local tags=""
  local last_line
  last_line=$(echo "$content" | tail -1)

  if echo "$last_line" | grep -qE '^#[a-zA-Z0-9_-]+'; then
    tags="$last_line"
    # Remove last line from content (portable way)
    text=$(echo "$content" | sed '$d')
  fi

  # Add to queue
  add_prompt "$text" "$tags"
}

# =============================================================================
# Snippet Functions
# =============================================================================

# List available snippets
list_snippets() {
  ensure_config
  mkdir -p "$SNIPPETS"

  if [[ ! -d "$SNIPPETS" ]] || [[ -z "$(ls -A "$SNIPPETS" 2>/dev/null)" ]]; then
    msg "$YELLOW" "📌 No snippets found in $SNIPPETS"
    msg "$BLUE" "Create .txt files with fixed prompts you want to reuse"
    return 0
  fi

  msg "$CYAN" "📌 Available snippets:"
  echo ""

  for snippet in "$SNIPPETS"/*.txt; do
    if [[ -f "$snippet" ]]; then
      local name
      name=$(basename "$snippet" .txt)

      # Show first line as preview (up to 60 chars)
      local preview
      preview=$(head -1 "$snippet" | cut -c1-60)
      if [[ ${#preview} -eq 60 ]]; then
        preview="${preview}..."
      fi

      printf "${GREEN}%-20s${RESET} ${BLUE}%s${RESET}\n" "$name" "$preview"
    fi
  done
}

# Show snippet content
show_snippet() {
  local name="$1"

  if [[ -z "$name" ]]; then
    die "Usage: promptq snippet show <name>"
  fi

  local snippet_file="${SNIPPETS}/${name}.txt"

  if [[ ! -f "$snippet_file" ]]; then
    die "Snippet not found: $name"
  fi

  msg "$CYAN" "📌 Snippet: $name"
  echo ""
  cat "$snippet_file"
}

# Add prompt from snippet
add_from_snippet() {
  local name="$1"

  if [[ -z "$name" ]]; then
    die "Usage: promptq snippet add <name>"
  fi

  local snippet_file="${SNIPPETS}/${name}.txt"

  if [[ ! -f "$snippet_file" ]]; then
    die "Snippet not found: $name"
  fi

  # Read snippet content
  local content
  content=$(cat "$snippet_file")

  # Extract tags from the last line if it starts with #
  local text="$content"
  local tags=""
  local last_line
  last_line=$(echo "$content" | tail -1)

  if echo "$last_line" | grep -qE '^#[a-zA-Z0-9_-]+'; then
    tags="$last_line"
    # Remove last line from content (portable way)
    text=$(echo "$content" | sed '$d')
  fi

  # Add to queue
  add_prompt "$text" "$tags"
}

# =============================================================================
# Send Functions
# =============================================================================

# Detect Claude Code pane in tmux
detect_claude_pane() {
  command -v tmux >/dev/null 2>&1 || return 1
  tmux list-sessions >/dev/null 2>&1 || return 1

  # helper: verify pane exists
  _exists() { tmux list-panes -a -F '#{pane_id}' 2>/dev/null | grep -qx "$1"; }

  # Priority 1: Use PROMPTQ_PANE environment variable if set
  if [[ -n "${PROMPTQ_PANE:-}" ]] && _exists "$PROMPTQ_PANE"; then
    echo "$PROMPTQ_PANE"
    return 0
  fi

  # Priority 2: Check config file for target_pane
  if [[ -f "$CONFIG" ]]; then
    local config_pane
    config_pane=$(grep -E '^target_pane=' "$CONFIG" 2>/dev/null | cut -d= -f2)
    if [[ -n "$config_pane" ]] && _exists "$config_pane"; then
      echo "$config_pane"
      return 0
    fi
  fi

  local pane_id=""

  # Priority 3: Current window, @role=claude (most specific)
  if [[ -n "${TMUX:-}" ]]; then
    local wid
    wid=$(tmux display -p '#{window_id}' 2>/dev/null)
    pane_id=$(
      tmux list-panes -F '#{window_id} #{pane_id} #{?@role,#{@role},-}' 2>/dev/null \
      | awk -v wid="$wid" 'tolower($1)==tolower(wid) && tolower($3)=="claude" {print $2; exit}'
    )
    if [[ -n "$pane_id" ]]; then
      echo "$pane_id"
      return 0
    fi
  fi

  # Priority 4: Any window, @role=claude (stable tag-based detection)
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{?@role,#{@role},-}' 2>/dev/null \
    | awk 'tolower($2)=="claude" {print $1; exit}'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  # Priority 5: Fallback - title contains "claude code"
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{pane_title}' 2>/dev/null \
    | awk 'tolower($2) ~ /claude[[:space:]]+code/ {print $1; exit}'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  # Priority 6: Fallback - command/title contains "claude" (exclude claude-monitor)
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{pane_current_command} #{pane_title}' 2>/dev/null \
    | awk 'BEGIN{IGNORECASE=1} $2 ~ /claude/ || $3 ~ /claude/ { if($2 !~ /claude-monitor/ && $3 !~ /claude-monitor/) {print $1; exit} }'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  return 1
}

# Send text to Claude via tmux
send_via_tmux() {
  local text="$1"
  local pane_id="$2"

  # Send text to pane (use -l for literal text, no key interpretation)
  if tmux send-keys -t "$pane_id" -l "$text" 2>/dev/null; then
    # Send Enter key
    tmux send-keys -t "$pane_id" Enter 2>/dev/null
    return 0
  fi

  return 1
}

# Send text to clipboard
send_via_clipboard() {
  local text="$1"

  if command -v pbcopy &> /dev/null; then
    echo "$text" | pbcopy
    return 0
  elif command -v xclip &> /dev/null; then
    echo "$text" | xclip -selection clipboard
    return 0
  elif command -v xsel &> /dev/null; then
    echo "$text" | xsel --clipboard
    return 0
  fi

  return 1
}

# Send first prompt in queue (FIFO)
send_prompt() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "📭 Queue is empty"
    return 0
  fi

  # Get first line
  local entry
  entry=$(head -1 "$QUEUE")
  local text
  text=$(echo "$entry" | jq -r '.text')

  msg "$CYAN" "📤 Sending: ${text:0:60}..."

  # Try tmux first
  local pane_id
  if pane_id=$(detect_claude_pane); then
    if send_via_tmux "$text" "$pane_id"; then
      msg "$GREEN" "✅ Sent via tmux (pane: $pane_id)"

      # Move to sent log and remove from queue
      echo "$entry" >> "$SENT"
      tail -n +2 "$QUEUE" > "${QUEUE}.tmp" && mv "${QUEUE}.tmp" "$QUEUE"

      msg "$BLUE" "📋 Remaining: $(count_queue) items"
      return 0
    fi
  else
    # If inside tmux but no claude found in current window
    if [[ -n "${TMUX:-}" ]]; then
      msg "$YELLOW" "⚠️  No Claude pane found in current window"
      msg "$BLUE" "Hint: Open Claude in this window, or set target pane:"
      msg "$BLUE" "  promptq config set-pane <pane_id>"
    fi
  fi

  # Try clipboard
  if send_via_clipboard "$text"; then
    msg "$YELLOW" "📋 Copied to clipboard (paste manually)"

    # Move to sent log and remove from queue
    echo "$entry" >> "$SENT"
    tail -n +2 "$QUEUE" > "${QUEUE}.tmp" && mv "${QUEUE}.tmp" "$QUEUE"

    msg "$BLUE" "📋 Remaining: $(count_queue) items"
    return 0
  fi

  # Fallback: print to stdout
  msg "$RED" "⚠️  Could not send automatically"
  msg "$YELLOW" "Please copy manually:"
  echo ""
  echo "$text"

  return 1
}

# Interactive send with fzf
select_and_send() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "📭 Queue is empty"
    return 0
  fi

  if ! command -v fzf &> /dev/null; then
    die "fzf is not installed. Install with: brew install fzf"
  fi

  # Format queue for fzf with safe preview
  # Create display format: index + truncated text + tags
  local display_lines
  display_lines=$(jq -r 'input_line_number as $n |
    ($n | tostring) + ". " +
    (.text | gsub("\n"; " ") | gsub("\\s+"; " ") | .[0:80]) +
    (if (.text | length) > 80 then "..." else "" end) +
    " " +
    (if (.tags | length) > 0 then (.tags | map("#" + .) | join(" ")) else "" end)' "$QUEUE")

  local selected_idx
  selected_idx=$(echo "$display_lines" | \
    fzf --height 50% \
        --reverse \
        --header "Select prompt to send (ESC to cancel)" \
        --preview "LINE=\$(echo {1} | tr -d '.'); sed -n \"\${LINE}p\" \"$QUEUE\" | jq -r '.text'" \
        --preview-window=up:3:wrap | \
    awk '{print $1}' | \
    tr -d '.')

  if [[ -z "$selected_idx" ]]; then
    msg "$YELLOW" "❌ Cancelled"
    return 0
  fi

  # Get selected entry
  local entry
  entry=$(sed -n "${selected_idx}p" "$QUEUE")
  local text
  text=$(echo "$entry" | jq -r '.text')

  msg "$CYAN" "📤 Sending: ${text:0:60}..."

  # Try tmux first
  local pane_id
  if pane_id=$(detect_claude_pane); then
    if send_via_tmux "$text" "$pane_id"; then
      msg "$GREEN" "✅ Sent via tmux (pane: $pane_id)"

      # Move to sent log and remove from queue
      echo "$entry" >> "$SENT"
      sed -i '' "${selected_idx}d" "$QUEUE"

      msg "$BLUE" "📋 Remaining: $(count_queue) items"
      return 0
    fi
  else
    # If inside tmux but no claude found in current window
    if [[ -n "${TMUX:-}" ]]; then
      msg "$YELLOW" "⚠️  No Claude pane found in current window"
      msg "$BLUE" "Hint: Open Claude in this window, or set target pane:"
      msg "$BLUE" "  promptq config set-pane <pane_id>"
    fi
  fi

  # Try clipboard
  if send_via_clipboard "$text"; then
    msg "$YELLOW" "📋 Copied to clipboard (paste manually)"

    # Move to sent log and remove from queue
    echo "$entry" >> "$SENT"
    sed -i '' "${selected_idx}d" "$QUEUE"

    msg "$BLUE" "📋 Remaining: $(count_queue) items"
    return 0
  fi

  # Fallback: print to stdout
  msg "$RED" "⚠️  Could not send automatically"
  msg "$YELLOW" "Please copy manually:"
  echo ""
  echo "$text"

  return 1
}

# =============================================================================
# Main CLI
# =============================================================================

show_help() {
  if has_gum; then
    # Rich help with gum
    gum style \
      --foreground 212 \
      --border double \
      --border-foreground 212 \
      --align center \
      --width 70 \
      --margin "1 0" \
      --padding "1 2" \
      --bold \
      "📋 promptq" \
      "Prompt Queue Manager for Claude Code"

    echo ""
    gum style --foreground 99 --bold "USAGE"
    echo "  promptq [--plain] <command> [arguments]"
    echo ""

    gum style --foreground 99 --bold "COMMANDS"
    {
      echo "Command|Arguments|Description"
      echo "add|<text> [#tags]|Add prompt to queue with optional tags"
      echo "list|─|List all queued prompts"
      echo "count|─|Show queue size"
      echo "send|─|Send first prompt (FIFO)"
      echo "select-send|─|Interactive send with fzf"
      echo "filter|<#tag>|Filter prompts by tag"
      echo "tags|─|List all tags with counts"
      echo "template list|─|List available templates"
      echo "template show|<name>|Show template content"
      echo "template add|<name> ...|Add from template with vars"
      echo "snippet list|─|List available snippets"
      echo "snippet show|<name>|Show snippet content"
      echo "snippet add|<name>|Add from snippet"
      echo "config set-pane|<pane>|Set target tmux pane"
      echo "config show-pane|─|Show current target pane"
      echo "clear|─|Clear all queued prompts"
      echo "help|─|Show this help"
      echo "version|─|Show version"
    } | gum table --separator "|" --border rounded --border.foreground 240 --print --widths "20,15,40"

    echo ""
    gum style --foreground 99 --bold "EXAMPLES"
    gum format << 'EOF'
```bash
# Add simple prompt
promptq add "Explain async/await in JavaScript"

# Add with tags
promptq add "Review this PR" #review #urgent

# Send first prompt
promptq send

# Interactive selection
promptq select-send

# Filter by tag
promptq filter #rust

# Use templates
promptq template add explain-concept CONCEPT="async/await" LANGUAGE="rust"
```
EOF

    echo ""
    gum style --foreground 99 --bold "LOCATIONS"
    gum style --border rounded --border-foreground 57 --padding "0 2" \
      "Queue:     ~/.config/promptq/queue.jsonl" \
      "Templates: ~/.config/promptq/templates/" \
      "Snippets:  ~/.config/promptq/snippets/"

    echo ""
    gum style --foreground 240 --italic "💡 Tip: Use --plain flag for script-friendly output"
  else
    # Fallback: simple text
    cat << 'EOF'
promptq - Prompt Queue Manager for Claude Code

Usage:
  promptq [--plain] <command> [arguments]

Commands:
  add <text> [#tags]        Add prompt to queue
  list                      List all queued prompts
  count                     Show queue size
  send                      Send first prompt (FIFO)
  select-send               Interactive send with fzf
  filter <#tag>             Filter prompts by tag
  tags                      List all tags with counts
  template list             List available templates
  template show <name>      Show template content
  template add <name> ...   Add prompt from template
  snippet list              List available snippets
  snippet show <name>       Show snippet content
  snippet add <name>        Add prompt from snippet
  config set-pane <pane>    Set target tmux pane
  config show-pane          Show current target pane
  clear                     Clear all queued prompts
  help                      Show this help
  version                   Show version

Examples:
  promptq add "Explain async/await in JavaScript"
  promptq add "Review this PR" #review #urgent
  promptq send
  promptq select-send
  promptq filter #rust
  promptq template add explain-concept CONCEPT="async/await" LANGUAGE="rust"

Locations:
  Queue:     ~/.config/promptq/queue.jsonl
  Templates: ~/.config/promptq/templates/
  Snippets:  ~/.config/promptq/snippets/

Send Priority:
  1. tmux send-keys (auto-detected Claude pane)
  2. Clipboard copy (pbcopy)
  3. Manual output to terminal
EOF
  fi
}

main() {
  # Parse global flags before command
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --plain|-p)
        PLAIN_OUTPUT=1
        shift
        ;;
      -*)
        msg "$RED" "Unknown flag: $1"
        echo ""
        show_help
        exit 1
        ;;
      *)
        break  # Not a flag, proceed to command
        ;;
    esac
  done

  local cmd="${1:-help}"

  case "$cmd" in
    add|a)
      shift
      if [[ $# -eq 0 ]]; then
        die "Usage: promptq add <text> [#tags]"
      fi

      local text="$1"
      shift
      local tags="$*"

      add_prompt "$text" "$tags"
      ;;

    list|ls|l)
      list_queue
      ;;

    count|c)
      echo "$(count_queue)"
      ;;

    send|s)
      send_prompt
      ;;

    select-send|ss)
      select_and_send
      ;;

    filter|f)
      shift
      if [[ $# -eq 0 ]]; then
        die "Usage: promptq filter #tag"
      fi
      filter_by_tag "$1"
      ;;

    tags|t)
      list_tags
      ;;

    template|tmpl)
      shift
      local subcmd="${1:-list}"
      shift || true

      case "$subcmd" in
        list|ls|l)
          list_templates
          ;;
        show|s)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq template show <name>"
          fi
          show_template "$1"
          ;;
        add|a)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq template add <name> [VAR=value ...]"
          fi
          add_from_template "$@"
          ;;
        *)
          msg "$RED" "Unknown template command: $subcmd"
          msg "$YELLOW" "Available: list, show, add"
          exit 1
          ;;
      esac
      ;;

    snippet|snip)
      shift
      local subcmd="${1:-list}"
      shift || true

      case "$subcmd" in
        list|ls|l)
          list_snippets
          ;;
        show|s)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq snippet show <name>"
          fi
          show_snippet "$1"
          ;;
        add|a)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq snippet add <name>"
          fi
          add_from_snippet "$1"
          ;;
        *)
          msg "$RED" "Unknown snippet command: $subcmd"
          msg "$YELLOW" "Available: list, show, add"
          exit 1
          ;;
      esac
      ;;

    config|cfg)
      shift
      local subcmd="${1:-}"
      shift || true

      case "$subcmd" in
        set-pane|sp)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq config set-pane <pane_id>"
          fi
          ensure_config
          echo "target_pane=$1" > "$CONFIG"
          msg "$GREEN" "✅ Target pane set to: $1"
          msg "$BLUE" "Verify with: promptq config show-pane"
          ;;
        show-pane|gp)
          if detect_claude_pane > /dev/null; then
            local pane
            pane=$(detect_claude_pane)
            msg "$CYAN" "🎯 Target pane: $pane"

            # Show pane details
            local pane_info
            pane_info=$(tmux list-panes -a -F '#{pane_id} #{pane_title} #{pane_current_command}' 2>/dev/null | command grep "^$pane ")
            if [[ -n "$pane_info" ]]; then
              msg "$BLUE" "   $pane_info"
            fi
          else
            msg "$RED" "❌ No Claude Code pane detected"
            msg "$YELLOW" "Set manually with: promptq config set-pane <pane_id>"
            msg "$YELLOW" "List panes: tmux list-panes -a"
          fi
          ;;
        *)
          msg "$RED" "Unknown config command: $subcmd"
          msg "$YELLOW" "Available: set-pane, show-pane"
          exit 1
          ;;
      esac
      ;;

    clear|clr)
      clear_queue
      ;;

    help|h|-h|--help)
      show_help
      ;;

    version|v|-v|--version)
      echo "promptq v${VERSION}"
      ;;

    *)
      msg "$RED" "Unknown command: $cmd"
      echo ""
      show_help
      exit 1
      ;;
  esac
}

main "$@"
