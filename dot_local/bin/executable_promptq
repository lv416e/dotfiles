#!/usr/bin/env bash
# =============================================================================
# promptq - Prompt Queue Manager for Coding Assistants
# =============================================================================
# A lightweight JSONL-based queue system for managing and sending prompts
# to Coding Assistants via tmux send-keys or clipboard.
#
# Usage:
#   promptq add "question text" [#tag1 #tag2]  - Add prompt to queue
#   promptq list                                - List all queued prompts
#   promptq count                               - Show queue size
#   promptq send                                - Send first prompt (FIFO)
#   promptq select-send                         - Interactive send with fzf
#   promptq clear                               - Clear all queued prompts
#   promptq help                                - Show this help
#
# Queue Format (JSONL):
#   {"ts":"2025-10-26T15:00:00+09:00","text":"Question","tags":["tag1"]}
#
# Send Priority:
#   1. tmux send-keys (if Claude detected in tmux pane)
#   2. Clipboard copy (pbcopy) with notification
#   3. Manual fallback with printed prompt
# =============================================================================

set -euo pipefail

# Configuration
readonly Q_DIR="${HOME}/.config/promptq"
readonly QUEUE="${Q_DIR}/queue.jsonl"
readonly SENT="${Q_DIR}/sent.jsonl"
readonly TEMPLATES="${Q_DIR}/templates"
readonly SNIPPETS="${Q_DIR}/snippets"
readonly CONFIG="${Q_DIR}/config"
readonly VERSION="0.1.0"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly RESET='\033[0m'

# =============================================================================
# Modern Rendering System
# =============================================================================

# Global flags
PLAIN_OUTPUT="${PLAIN_OUTPUT:-0}"  # Disable styling when set to 1
KEEP_QUEUE="${KEEP_QUEUE:-0}"      # Keep items in queue after sending when set to 1

# Check if gum is available (respects PLAIN_OUTPUT flag)
has_gum() {
  [[ "$PLAIN_OUTPUT" == "0" ]] && command -v gum >/dev/null 2>&1
}

# Render bordered header without emoji
# Usage: render_header "text"
render_header() {
  local text="$1"

  if has_gum; then
    gum style \
      --foreground 57 \
      --border-foreground 57 \
      --border rounded \
      --padding "0 2" \
      --bold \
      "$text"
  else
    # Fallback: Unicode box drawing
    local len=${#text}
    local border_len=$((len + 4))

    printf "╭"
    printf '─%.0s' $(seq 1 $border_len)
    printf "╮\n"

    printf "│  %s  │\n" "$text"

    printf "╰"
    printf '─%.0s' $(seq 1 $border_len)
    printf "╯\n"
  fi
  echo ""  # Empty line after header
}

# Render table from pipe-delimited data
# Usage: echo "header|data" | render_table
render_table() {
  if has_gum; then
    gum table \
      --separator "|" \
      --border rounded \
      --border.foreground 240 \
      --print
  else
    # Fallback: column command with simpler formatting
    local lines=()
    while IFS= read -r line; do
      lines+=("$line")
    done

    # Format all lines with column first
    local formatted
    formatted=$(printf '%s\n' "${lines[@]}" | column -t -s "|")

    # Print with separator after header
    local idx=0
    while IFS= read -r line; do
      if [[ $idx -eq 0 ]]; then
        # Header line
        echo " $line"
        # Generate separator line (simple dashes)
        local len=${#line}
        printf " "
        printf '─%.0s' $(seq 1 $len)
        echo ""
      else
        # Data lines
        echo " $line"
      fi
      ((idx++))
    done <<< "$formatted"
  fi
}

# Format timestamp as relative time
# Usage: relative_time "2025-10-27T10:30:00+0900"
relative_time() {
  local ts="$1"
  local now=$(date +%s)

  # Try to parse timestamp (macOS date format)
  local then
  then=$(date -j -f "%Y-%m-%dT%H:%M:%S%z" "$ts" +%s 2>/dev/null || echo "$now")

  local diff=$((now - then))

  if [ $diff -lt 0 ]; then
    echo "Just now"
  elif [ $diff -lt 60 ]; then
    echo "Just now"
  elif [ $diff -lt 3600 ]; then
    local mins=$((diff / 60))
    echo "${mins}m ago"
  elif [ $diff -lt 86400 ]; then
    local hours=$((diff / 3600))
    echo "${hours}h ago"
  elif [ $diff -lt 604800 ]; then
    local days=$((diff / 86400))
    if [ $days -eq 1 ]; then
      echo "Yesterday"
    else
      echo "${days}d ago"
    fi
  else
    # More than a week: show date
    date -j -f "%Y-%m-%dT%H:%M:%S%z" "$ts" "+%Y-%m-%d" 2>/dev/null || echo "$ts"
  fi
}

# Style text with color
# Usage: style_text "212" "text"
style_text() {
  local color="$1"
  local text="$2"

  if has_gum; then
    gum style --foreground "$color" "$text"
  else
    # Fallback: Use existing color codes
    case "$color" in
      212|magenta) echo -e "${MAGENTA}${text}${RESET}" ;;
      57|blue) echo -e "${BLUE}${text}${RESET}" ;;
      99|cyan) echo -e "${CYAN}${text}${RESET}" ;;
      240|gray) echo -e "${text}" ;;  # No gray in basic ANSI
      *) echo "$text" ;;
    esac
  fi
}

# =============================================================================
# Utility Functions
# =============================================================================

# Print colored message
msg() {
  local color="$1"
  shift
  echo -e "${color}${*}${RESET}"
}

# Print error and exit
die() {
  msg "$RED" "Error: $*" >&2
  exit 1
}

# Ensure config directory and queue file exist
ensure_config() {
  mkdir -p "$Q_DIR"
  touch "$QUEUE" "$SENT"
}

# Get ISO 8601 timestamp with timezone
timestamp() {
  date +"%Y-%m-%dT%H:%M:%S%z"
}

# Get preferred editor (respects $VISUAL, $EDITOR, falls back to common editors)
# Prioritizes lightweight modern editors: helix > nvim > vim
get_editor() {
  if [[ -n "${VISUAL:-}" ]]; then
    echo "$VISUAL"
  elif [[ -n "${EDITOR:-}" ]]; then
    echo "$EDITOR"
  elif command -v helix &>/dev/null; then
    echo "helix"
  elif command -v hx &>/dev/null; then
    echo "hx"
  elif command -v nvim &>/dev/null; then
    echo "nvim"
  elif command -v vim &>/dev/null; then
    echo "vim"
  elif command -v nano &>/dev/null; then
    echo "nano"
  elif command -v vi &>/dev/null; then
    echo "vi"
  else
    die "No editor found. Please set \$EDITOR or \$VISUAL environment variable."
  fi
}

# Backup queue file
backup_queue() {
  if [[ -f "$QUEUE" ]]; then
    cp "$QUEUE" "${QUEUE}.bak"
  fi
}

# Restore queue file from backup
restore_queue() {
  if [[ -f "${QUEUE}.bak" ]]; then
    mv "${QUEUE}.bak" "$QUEUE"
  fi
}

# Validate JSONL file integrity
validate_jsonl() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    return 1
  fi

  # Check if each line is valid JSON
  while IFS= read -r line; do
    if [[ -n "$line" ]] && ! echo "$line" | jq empty 2>/dev/null; then
      return 1
    fi
  done < "$file"

  return 0
}

# =============================================================================
# File Locking Functions (mkdir-based, no external dependencies)
# =============================================================================

# Lock directory path
readonly LOCK_DIR="${Q_DIR}/.lock"

# Acquire lock with timeout and stale lock detection
# Usage: acquire_lock [timeout_seconds]
acquire_lock() {
  local timeout="${1:-10}"  # Default 10 seconds
  local waited=0

  while ! mkdir "$LOCK_DIR" 2>/dev/null; do
    sleep 0.1
    waited=$((waited + 1))

    if [ $waited -gt $((timeout * 10)) ]; then
      # Check for stale lock (process no longer running)
      if is_stale_lock; then
        msg "$YELLOW" "Removing stale lock..."
        release_lock
        continue  # Retry
      fi

      die "Failed to acquire lock (timeout after ${timeout}s). Another promptq process may be running."
    fi
  done

  # Store PID for stale lock detection
  echo $$ > "${LOCK_DIR}/pid"

  # Ensure cleanup on exit/interruption
  trap "release_lock" EXIT INT TERM HUP
}

# Release lock
release_lock() {
  rm -f "${LOCK_DIR}/pid" 2>/dev/null
  rmdir "$LOCK_DIR" 2>/dev/null || true
}

# Check if lock is stale (process no longer running)
is_stale_lock() {
  if [[ ! -f "${LOCK_DIR}/pid" ]]; then
    return 0  # No PID file, consider stale
  fi

  local lock_pid
  lock_pid=$(cat "${LOCK_DIR}/pid" 2>/dev/null)

  # Check if process is still running
  if [[ -n "$lock_pid" ]] && ! ps -p "$lock_pid" >/dev/null 2>&1; then
    return 0  # Process not running, lock is stale
  fi

  return 1  # Lock is valid
}

# =============================================================================
# Queue Management Functions
# =============================================================================

# Add prompt to queue
# Usage: add_prompt "text" ["#tag1 #tag2"]
add_prompt() {
  ensure_config
  acquire_lock

  local text="$1"
  local tags="${2:-}"

  if [[ -z "$text" ]]; then
    die "Prompt text cannot be empty"
  fi

  # Extract tags (words starting with #)
  local tag_array="[]"
  if [[ -n "$tags" ]]; then
    # Convert "#tag1 #tag2" to ["tag1","tag2"]
    tag_array=$(echo "$tags" | grep -oE '#[a-zA-Z0-9_-]+' | sed 's/#//g' | jq -R -s -c 'split("\n") | map(select(length > 0))')
  fi

  # Create JSON entry using jq for safe escaping (compact format)
  local entry
  entry=$(jq -n -c \
    --arg ts "$(timestamp)" \
    --arg text "$text" \
    --argjson tags "$tag_array" \
    '{ts: $ts, text: $text, tags: $tags}')

  echo "$entry" >> "$QUEUE"
  msg "$GREEN" "Added to queue ($(count_queue) items)"

  release_lock
}

# List all queued prompts
list_queue() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    render_header "Queue is empty"
    return 0
  fi

  render_header "Prompt Queue - $count items"

  # Build table data
  {
    echo "#|Prompt|Tags|Added"

    local idx=1
    while IFS= read -r line; do
      local text tags ts rel_time
      text=$(echo "$line" | jq -r '.text')
      tags=$(echo "$line" | jq -r '.tags | join(" #")' | sed 's/^/#/')
      ts=$(echo "$line" | jq -r '.ts')

      # Replace newlines with spaces for single-line display
      text=$(echo "$text" | tr '\n' ' ' | tr -s ' ')

      # Truncate long text for table
      if [[ ${#text} -gt 35 ]]; then
        text="${text:0:32}..."
      fi

      # Clean up tags display
      if [[ "$tags" == "#" ]]; then
        tags=""
      fi

      # Get relative time
      rel_time=$(relative_time "$ts")

      echo "$idx|$text|$tags|$rel_time"
      ((idx++))
    done < "$QUEUE"
  } | render_table
}

# Count queued prompts
count_queue() {
  ensure_config
  wc -l < "$QUEUE" | tr -d ' '
}

# Clear all queued prompts
clear_queue() {
  ensure_config
  acquire_lock

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "Queue is already empty"
    release_lock
    return 0
  fi

  # Backup to sent log before clearing
  if [[ -s "$QUEUE" ]]; then
    cat "$QUEUE" >> "$SENT"
  fi

  > "$QUEUE"
  msg "$GREEN" "Cleared $count items from queue"

  release_lock
}

# Filter queue by tag
filter_by_tag() {
  ensure_config

  local tag="$1"
  # Remove # prefix if present
  tag="${tag#\#}"

  if [[ -z "$tag" ]]; then
    die "Usage: promptq filter #tag"
  fi

  local count=0
  local idx=1

  msg "$CYAN" "Prompts tagged with #${tag}:"
  echo ""

  while IFS= read -r line; do
    local tags_array
    tags_array=$(echo "$line" | jq -r '.tags[]' 2>/dev/null)

    # Check if tag exists in array
    if echo "$tags_array" | grep -qx "$tag"; then
      local text
      text=$(echo "$line" | jq -r '.text')
      local all_tags
      all_tags=$(echo "$line" | jq -r '.tags | join(" #")' | sed 's/^/#/')

      # Replace newlines with spaces for single-line display
      text=$(echo "$text" | tr '\n' ' ' | tr -s ' ')

      # Truncate long text
      if [[ ${#text} -gt 80 ]]; then
        text="${text:0:77}..."
      fi

      printf "${BLUE}%2d${RESET}. %s ${MAGENTA}%s${RESET}\n" "$idx" "$text" "$all_tags"
      ((count++))
    fi
    ((idx++))
  done < "$QUEUE"

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "No prompts found with tag #${tag}"
  fi
}

# List all unique tags
list_tags() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    render_header "No tags yet"
    return 0
  fi

  render_header "Tags in Queue"

  # Build table data
  {
    echo "Tag|Count"

    # Extract all tags, sort, and count occurrences
    jq -r '.tags[]' "$QUEUE" 2>/dev/null | sort | uniq -c | sort -rn | while read -r cnt tag; do
      echo "#$tag|$cnt"
    done
  } | render_table
}

# Delete queue items by number or with fzf multi-select
# Usage: delete_queue_item [number...]
delete_queue_item() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "Queue is empty. Nothing to delete."
    return 0
  fi

  local item_nums=()

  # If no arguments, use fzf for multi-select
  if [[ $# -eq 0 ]]; then
    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide item numbers: promptq delete <number...>"
    fi

    msg "$CYAN" "Select items to delete (TAB for multi-select, ESC to cancel):"
    echo ""

    # Build fzf list
    local selections
    selections=$(awk 'BEGIN{idx=1} {
      text=$0;
      gsub(/.*"text":"/, "", text);
      gsub(/","tags.*/, "", text);
      if (length(text) > 60) text = substr(text, 1, 57) "...";
      printf "%d. %s\n", idx++, text;
    }' "$QUEUE" | fzf --multi --height=40% --reverse --prompt="Delete> " \
      --header="TAB to select multiple, ENTER to confirm" --preview-window=hidden)

    if [[ -z "$selections" ]]; then
      msg "$YELLOW" "No items selected."
      return 0
    fi

    # Extract numbers from selections
    while IFS= read -r line; do
      item_nums+=($(echo "$line" | awk '{print $1}' | tr -d '.'))
    done <<< "$selections"
  else
    # Use provided arguments as item numbers
    item_nums=("$@")
  fi

  # Validate all item numbers
  for num in "${item_nums[@]}"; do
    if ! [[ "$num" =~ ^[0-9]+$ ]] || [[ $num -lt 1 ]] || [[ $num -gt $count ]]; then
      die "Invalid item number: $num. Please provide numbers between 1 and $count."
    fi
  done

  # Sort in reverse order to delete from end (avoid index shifting)
  IFS=$'\n' sorted_nums=($(sort -rn <<<"${item_nums[*]}"))
  unset IFS

  acquire_lock

  # Delete each item
  for idx in "${sorted_nums[@]}"; do
    sed -i '' "${idx}d" "$QUEUE"
  done

  release_lock

  local deleted_count=${#item_nums[@]}
  msg "$GREEN" "Deleted $deleted_count item(s) from queue"
  msg "$BLUE" "Remaining: $(count_queue) items"
}

# Add tags to a queue item
# Usage: tag_add_to_item [item_number] [tag1 tag2...]
tag_add_to_item() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    die "Queue is empty"
  fi

  local item_num=""
  local new_tags=()

  # Parse arguments
  if [[ $# -eq 0 ]]; then
    # No arguments: use fzf to select item, then prompt for tags
    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide arguments: promptq tag-add <item_number> <tag1> [tag2...]"
    fi

    msg "$CYAN" "Select item to add tags:"
    echo ""

    local selection
    selection=$(awk 'BEGIN{idx=1} {
      text=$0;
      gsub(/.*"text":"/, "", text);
      gsub(/","tags.*/, "", text);
      if (length(text) > 60) text = substr(text, 1, 57) "...";
      printf "%d. %s\n", idx++, text;
    }' "$QUEUE" | fzf --height=40% --reverse --prompt="Add tags> " --preview-window=hidden)

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No item selected."
      return 0
    fi

    item_num=$(echo "$selection" | awk '{print $1}' | tr -d '.')

    # Prompt for tags
    msg "$CYAN" "Enter tags (space-separated, # prefix optional):"
    read -r tags_input
    if [[ -z "$tags_input" ]]; then
      msg "$YELLOW" "No tags provided."
      return 0
    fi
    read -ra new_tags <<< "$tags_input"

  elif [[ $# -eq 1 ]]; then
    # One argument: treat as item_number, prompt for tags
    item_num="$1"

    msg "$CYAN" "Enter tags (space-separated, # prefix optional):"
    read -r tags_input
    if [[ -z "$tags_input" ]]; then
      msg "$YELLOW" "No tags provided."
      return 0
    fi
    read -ra new_tags <<< "$tags_input"

  else
    # Two or more arguments: item_number + tags
    item_num="$1"
    shift
    new_tags=("$@")
  fi

  # Validate item number
  if ! [[ "$item_num" =~ ^[0-9]+$ ]] || [[ $item_num -lt 1 ]] || [[ $item_num -gt $count ]]; then
    die "Invalid item number. Please provide a number between 1 and $count."
  fi

  # Clean tags (remove # prefix if present)
  local cleaned_tags=()
  for tag in "${new_tags[@]}"; do
    cleaned_tags+=("${tag#\#}")
  done

  acquire_lock

  # Get the line
  local line
  line=$(sed -n "${item_num}p" "$QUEUE")

  if [[ -z "$line" ]]; then
    release_lock
    die "Failed to read item #${item_num}"
  fi

  # Extract current data
  local current_text current_tags current_ts
  current_text=$(echo "$line" | jq -r '.text')
  current_tags=$(echo "$line" | jq -r '.tags')
  current_ts=$(echo "$line" | jq -r '.ts')

  # Merge and deduplicate tags
  local merged_tags
  merged_tags=$(echo "$current_tags" | jq -c --arg newtags "${cleaned_tags[*]}" \
    '. + ($newtags | split(" ")) | unique | sort')

  # Backup queue before modifying
  backup_queue

  # Create new JSON entry with updated tags
  local new_entry
  new_entry=$(jq -nc \
    --arg text "$current_text" \
    --argjson tags "$merged_tags" \
    --arg ts "$current_ts" \
    '{ts: $ts, text: $text, tags: $tags}')

  # Replace the line in queue
  {
    if [[ $item_num -gt 1 ]]; then
      head -n $((item_num - 1)) "$QUEUE"
    fi
    echo "$new_entry"
    if [[ $item_num -lt $count ]]; then
      tail -n +$((item_num + 1)) "$QUEUE"
    fi
  } > "${QUEUE}.new"

  mv "${QUEUE}.new" "$QUEUE"

  # Validate JSONL integrity
  if ! validate_jsonl "$QUEUE"; then
    restore_queue
    release_lock
    die "Queue file became corrupted. Restored from backup."
  fi

  rm -f "${QUEUE}.bak"
  release_lock

  # Show added tags
  msg "$GREEN" "Added tags to item #${item_num}: ${cleaned_tags[*]}"
}

# Remove tags from a queue item
# Usage: tag_remove_from_item [item_number] [tag1 tag2...]
tag_remove_from_item() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    die "Queue is empty"
  fi

  local item_num=""
  local remove_tags=()

  # Parse arguments
  if [[ $# -eq 0 ]]; then
    # No arguments: use fzf to select item, then select tags with fzf
    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide arguments: promptq tag-remove <item_number> <tag1> [tag2...]"
    fi

    msg "$CYAN" "Select item to remove tags from:"
    echo ""

    local selection
    selection=$(awk 'BEGIN{idx=1} {
      text=$0;
      gsub(/.*"text":"/, "", text);
      gsub(/","tags.*/, "", text);
      if (length(text) > 60) text = substr(text, 1, 57) "...";
      printf "%d. %s\n", idx++, text;
    }' "$QUEUE" | fzf --height=40% --reverse --prompt="Remove tags> " --preview-window=hidden)

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No item selected."
      return 0
    fi

    item_num=$(echo "$selection" | awk '{print $1}' | tr -d '.')

  elif [[ $# -eq 1 ]]; then
    # One argument: treat as item_number
    item_num="$1"

  else
    # Two or more arguments: item_number + tags
    item_num="$1"
    shift
    remove_tags=("$@")
  fi

  # Validate item number
  if ! [[ "$item_num" =~ ^[0-9]+$ ]] || [[ $item_num -lt 1 ]] || [[ $item_num -gt $count ]]; then
    die "Invalid item number. Please provide a number between 1 and $count."
  fi

  # Get the line to check existing tags
  local line
  line=$(sed -n "${item_num}p" "$QUEUE")

  if [[ -z "$line" ]]; then
    die "Failed to read item #${item_num}"
  fi

  # Extract current data
  local current_text current_tags current_ts
  current_text=$(echo "$line" | jq -r '.text')
  current_tags=$(echo "$line" | jq -r '.tags')
  current_ts=$(echo "$line" | jq -r '.ts')

  # If no tags specified yet, use fzf to select from existing tags
  if [[ ${#remove_tags[@]} -eq 0 ]]; then
    local existing_tags
    existing_tags=$(echo "$current_tags" | jq -r '.[]' 2>/dev/null)

    if [[ -z "$existing_tags" ]]; then
      msg "$YELLOW" "Item #${item_num} has no tags to remove."
      return 0
    fi

    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide tags: promptq tag-remove ${item_num} <tag1> [tag2...]"
    fi

    msg "$CYAN" "Select tags to remove (TAB for multi-select, ESC to cancel):"
    echo ""

    local selected_tags
    selected_tags=$(echo "$existing_tags" | fzf --multi --height=40% --reverse --prompt="Remove> " \
      --header="TAB to select multiple, ENTER to confirm" --preview-window=hidden)

    if [[ -z "$selected_tags" ]]; then
      msg "$YELLOW" "No tags selected."
      return 0
    fi

    while IFS= read -r tag; do
      remove_tags+=("$tag")
    done <<< "$selected_tags"
  fi

  # Clean tags (remove # prefix if present)
  local cleaned_tags=()
  for tag in "${remove_tags[@]}"; do
    cleaned_tags+=("${tag#\#}")
  done

  acquire_lock

  # Remove specified tags
  local filtered_tags
  filtered_tags=$(echo "$current_tags" | jq -c --arg removetags "${cleaned_tags[*]}" \
    '. - ($removetags | split(" "))')

  # Backup queue before modifying
  backup_queue

  # Create new JSON entry with updated tags
  local new_entry
  new_entry=$(jq -nc \
    --arg text "$current_text" \
    --argjson tags "$filtered_tags" \
    --arg ts "$current_ts" \
    '{ts: $ts, text: $text, tags: $tags}')

  # Replace the line in queue
  {
    if [[ $item_num -gt 1 ]]; then
      head -n $((item_num - 1)) "$QUEUE"
    fi
    echo "$new_entry"
    if [[ $item_num -lt $count ]]; then
      tail -n +$((item_num + 1)) "$QUEUE"
    fi
  } > "${QUEUE}.new"

  mv "${QUEUE}.new" "$QUEUE"

  # Validate JSONL integrity
  if ! validate_jsonl "$QUEUE"; then
    restore_queue
    release_lock
    die "Queue file became corrupted. Restored from backup."
  fi

  rm -f "${QUEUE}.bak"
  release_lock

  # Show removed tags
  msg "$GREEN" "Removed tags from item #${item_num}: ${cleaned_tags[*]}"
}

# Edit a queue item by number (or select with fzf if no number provided)
# Usage: edit_queue_item [number]
edit_queue_item() {
  ensure_config

  local item_num="$1"
  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "Queue is empty. Nothing to edit."
    return 1
  fi

  # If no item number provided, use fzf to select
  if [[ -z "$item_num" ]]; then
    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide item number: promptq edit <number>"
    fi

    msg "$CYAN" "Select item to edit:"
    echo ""

    # Build fzf list with preview
    local selection
    selection=$(awk 'BEGIN{idx=1} {
      text=$0;
      gsub(/.*"text":"/, "", text);
      gsub(/","tags.*/, "", text);
      if (length(text) > 60) text = substr(text, 1, 57) "...";
      printf "%d. %s\n", idx++, text;
    }' "$QUEUE" | fzf --height=40% --reverse --prompt="Edit> " --preview-window=hidden)

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No item selected."
      return 1
    fi

    # Extract number from selection
    item_num=$(echo "$selection" | awk '{print $1}' | tr -d '.')
  fi

  # Validate item number
  if ! [[ "$item_num" =~ ^[0-9]+$ ]] || [[ $item_num -lt 1 ]] || [[ $item_num -gt $count ]]; then
    die "Invalid item number. Please provide a number between 1 and $count."
  fi

  # Get the line
  local line
  line=$(sed -n "${item_num}p" "$QUEUE")

  if [[ -z "$line" ]]; then
    die "Failed to read item #${item_num}"
  fi

  # Extract current data
  local current_text current_tags current_ts
  current_text=$(echo "$line" | jq -r '.text')
  current_tags=$(echo "$line" | jq -r '.tags')
  current_ts=$(echo "$line" | jq -r '.ts')

  # Create temp file with current text
  local temp_file
  temp_file=$(mktemp "${TMPDIR:-/tmp}/promptq.XXXXXX")
  echo "$current_text" > "$temp_file"

  # Get editor
  local editor
  editor=$(get_editor)

  # Show what we're editing
  msg "$CYAN" "Opening item #${item_num} in ${editor}..."

  # Open editor
  if ! "$editor" "$temp_file"; then
    rm -f "$temp_file"
    die "Editor exited with error"
  fi

  # Read edited content
  local new_text
  new_text=$(<"$temp_file")
  rm -f "$temp_file"

  # Check if content changed
  if [[ "$new_text" == "$current_text" ]]; then
    msg "$YELLOW" "No changes made."
    return 0
  fi

  # Validate new text
  if [[ -z "$new_text" ]] || [[ "$new_text" =~ ^[[:space:]]*$ ]]; then
    die "Prompt text cannot be empty"
  fi

  # Acquire lock before modifying queue
  acquire_lock

  # Backup queue before modifying
  backup_queue

  # Create new JSON entry with updated text (compact format for JSONL)
  local new_entry
  new_entry=$(jq -nc \
    --arg text "$new_text" \
    --argjson tags "$current_tags" \
    --arg ts "$current_ts" \
    '{ts: $ts, text: $text, tags: $tags}')

  # Replace the line in queue (build new file without modifying original first)
  {
    # Lines before the edited line
    if [[ $item_num -gt 1 ]]; then
      head -n $((item_num - 1)) "$QUEUE"
    fi

    # The edited line
    echo "$new_entry"

    # Lines after the edited line
    if [[ $item_num -lt $count ]]; then
      tail -n +$((item_num + 1)) "$QUEUE"
    fi
  } > "${QUEUE}.new"

  # Replace original with new file
  mv "${QUEUE}.new" "$QUEUE"

  # Validate JSONL integrity
  if ! validate_jsonl "$QUEUE"; then
    restore_queue
    die "Queue file became corrupted. Restored from backup."
  fi

  # Clean up backup
  rm -f "${QUEUE}.bak"

  release_lock

  # Success message
  msg "$GREEN" "Updated item #${item_num}"
  echo ""
  msg "$CYAN" "Before:"
  echo "$current_text" | head -3
  if [[ $(echo "$current_text" | wc -l) -gt 3 ]]; then
    echo "..."
  fi
  echo ""
  msg "$CYAN" "After:"
  echo "$new_text" | head -3
  if [[ $(echo "$new_text" | wc -l) -gt 3 ]]; then
    echo "..."
  fi
}

# =============================================================================
# Template Functions
# =============================================================================

# List available templates
list_templates() {
  ensure_config
  mkdir -p "$TEMPLATES"

  if [[ ! -d "$TEMPLATES" ]] || [[ -z "$(ls -A "$TEMPLATES" 2>/dev/null)" ]]; then
    msg "$YELLOW" "No templates found in $TEMPLATES"
    msg "$BLUE" "Create templates with .tmpl extension and use \${VARIABLE} for substitution"
    return 0
  fi

  local count=0
  for template in "$TEMPLATES"/*.tmpl; do
    if [[ -f "$template" ]]; then
      ((count++))
    fi
  done

  if has_gum; then
    # Modern table display with gum
    {
      echo "Name|Variables|Preview"
      for template in "$TEMPLATES"/*.tmpl; do
        if [[ -f "$template" ]]; then
          local name
          name=$(basename "$template" .tmpl)

          # Extract variables from template
          local vars
          vars=$(grep -oE '\$\{[A-Z_]+\}' "$template" 2>/dev/null | sort -u | sed 's/\${\(.*\)}/\1/' | tr '\n' ' ' || echo "-")
          vars=$(echo "$vars" | sed 's/ *$//')
          if [[ -z "$vars" ]]; then
            vars="-"
          fi

          # Get first line as preview
          local preview
          preview=$(head -1 "$template" | cut -c1-40)
          if [[ ${#preview} -ge 40 ]]; then
            preview="${preview}..."
          fi

          echo "$name|$vars|$preview"
        fi
      done
    } | gum table --separator "|" --border rounded --border.foreground 99 --print --widths "20,30,40"
  else
    # Fallback: simple text display
    msg "$CYAN" "Available templates ($count):"
    echo ""

    for template in "$TEMPLATES"/*.tmpl; do
      if [[ -f "$template" ]]; then
        local name
        name=$(basename "$template" .tmpl)

        # Extract variables from template
        local vars
        vars=$(grep -oE '\$\{[A-Z_]+\}' "$template" 2>/dev/null | sort -u | sed 's/\${\(.*\)}/\1/' | tr '\n' ' ' || echo "")

        printf "${GREEN}%-20s${RESET} " "$name"
        if [[ -n "$vars" ]]; then
          printf "${BLUE}Variables: ${YELLOW}%s${RESET}\n" "$vars"
        else
          echo ""
        fi
      fi
    done
  fi
}

# Show template content (or select with fzf if no name provided)
# Usage: show_template [name]
show_template() {
  local name="$1"

  # If no name provided, use fzf to select
  if [[ -z "$name" ]]; then
    mkdir -p "$TEMPLATES"

    if [[ ! -d "$TEMPLATES" ]] || [[ -z "$(ls -A "$TEMPLATES" 2>/dev/null)" ]]; then
      msg "$YELLOW" "No templates found in $TEMPLATES"
      return 1
    fi

    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide template name: promptq template show <name>"
    fi

    msg "$CYAN" "Select template to show:"
    echo ""

    local selection
    if command -v bat &>/dev/null; then
      selection=$(cd "$TEMPLATES" && ls -1 *.tmpl 2>/dev/null | sed 's/\.tmpl$//' | fzf --height=40% --reverse --prompt="Template> " --preview "bat --color=always --style=numbers '$TEMPLATES/{}.tmpl'" --preview-window=right:60%:wrap)
    else
      selection=$(cd "$TEMPLATES" && ls -1 *.tmpl 2>/dev/null | sed 's/\.tmpl$//' | fzf --height=40% --reverse --prompt="Template> " --preview "cat '$TEMPLATES/{}.tmpl'" --preview-window=right:60%:wrap)
    fi

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No template selected."
      return 1
    fi

    name="$selection"
  fi

  local template_file="${TEMPLATES}/${name}.tmpl"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $name"
  fi

  msg "$CYAN" "Template: $name"
  echo ""
  cat "$template_file"
}

# Add prompt from template
add_from_template() {
  local name="$1"
  shift

  if [[ -z "$name" ]]; then
    die "Usage: promptq template add <name> [VAR=value ...]"
  fi

  local template_file="${TEMPLATES}/${name}.tmpl"

  if [[ ! -f "$template_file" ]]; then
    die "Template not found: $name"
  fi

  # Read template content
  local content
  content=$(cat "$template_file")

  # Parse and substitute variables directly
  for arg in "$@"; do
    if [[ "$arg" =~ ^([A-Z_]+)=(.*)$ ]]; then
      local var="${BASH_REMATCH[1]}"
      local val="${BASH_REMATCH[2]}"
      # Replace all occurrences of ${VAR} with value
      content="${content//\$\{${var}\}/${val}}"
    fi
  done

  # Check for unsubstituted variables
  if echo "$content" | grep -qE '\$\{[A-Z_]+\}'; then
    local missing
    missing=$(echo "$content" | grep -oE '\$\{[A-Z_]+\}' | sort -u | tr '\n' ' ')
    msg "$RED" "Warning: Missing required variables: $missing"
    msg "$YELLOW" "Example: promptq template add $name VAR=value"
    return 1
  fi

  # Extract tags from the last line if it starts with #
  local text="$content"
  local tags=""
  local last_line
  last_line=$(echo "$content" | tail -1)

  if echo "$last_line" | grep -qE '^#[a-zA-Z0-9_-]+'; then
    tags="$last_line"
    # Remove last line from content (portable way)
    text=$(echo "$content" | sed '$d')
  fi

  # Add to queue
  add_prompt "$text" "$tags"
}

# =============================================================================
# Snippet Functions
# =============================================================================

# List available snippets
list_snippets() {
  ensure_config
  mkdir -p "$SNIPPETS"

  if [[ ! -d "$SNIPPETS" ]] || [[ -z "$(ls -A "$SNIPPETS" 2>/dev/null)" ]]; then
    msg "$YELLOW" "No snippets found in $SNIPPETS"
    msg "$BLUE" "Create .txt files with fixed prompts you want to reuse"
    return 0
  fi

  local count=0
  for snippet in "$SNIPPETS"/*.txt; do
    if [[ -f "$snippet" ]]; then
      ((count++))
    fi
  done

  if has_gum; then
    # Modern table display with gum
    {
      echo "Name|Preview"
      for snippet in "$SNIPPETS"/*.txt; do
        if [[ -f "$snippet" ]]; then
          local name
          name=$(basename "$snippet" .txt)

          # Show first line as preview
          local preview
          preview=$(head -1 "$snippet" | cut -c1-60)
          if [[ ${#preview} -ge 60 ]]; then
            preview="${preview}..."
          fi

          echo "$name|$preview"
        fi
      done
    } | gum table --separator "|" --border rounded --border.foreground 99 --print --widths "25,65"
  else
    # Fallback: simple text display
    msg "$CYAN" "Available snippets ($count):"
    echo ""

    for snippet in "$SNIPPETS"/*.txt; do
      if [[ -f "$snippet" ]]; then
        local name
        name=$(basename "$snippet" .txt)

        # Show first line as preview (up to 60 chars)
        local preview
        preview=$(head -1 "$snippet" | cut -c1-60)
        if [[ ${#preview} -eq 60 ]]; then
          preview="${preview}..."
        fi

        printf "${GREEN}%-20s${RESET} ${BLUE}%s${RESET}\n" "$name" "$preview"
      fi
    done
  fi
}

# Show snippet content (or select with fzf if no name provided)
# Usage: show_snippet [name]
show_snippet() {
  local name="$1"

  # If no name provided, use fzf to select
  if [[ -z "$name" ]]; then
    mkdir -p "$SNIPPETS"

    if [[ ! -d "$SNIPPETS" ]] || [[ -z "$(ls -A "$SNIPPETS" 2>/dev/null)" ]]; then
      msg "$YELLOW" "No snippets found in $SNIPPETS"
      return 1
    fi

    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide snippet name: promptq snippet show <name>"
    fi

    msg "$CYAN" "Select snippet to show:"
    echo ""

    local selection
    if command -v bat &>/dev/null; then
      selection=$(cd "$SNIPPETS" && ls -1 *.txt 2>/dev/null | sed 's/\.txt$//' | fzf --height=40% --reverse --prompt="Snippet> " --preview "bat --color=always --style=numbers '$SNIPPETS/{}.txt'" --preview-window=right:60%:wrap)
    else
      selection=$(cd "$SNIPPETS" && ls -1 *.txt 2>/dev/null | sed 's/\.txt$//' | fzf --height=40% --reverse --prompt="Snippet> " --preview "cat '$SNIPPETS/{}.txt'" --preview-window=right:60%:wrap)
    fi

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No snippet selected."
      return 1
    fi

    name="$selection"
  fi

  local snippet_file="${SNIPPETS}/${name}.txt"

  if [[ ! -f "$snippet_file" ]]; then
    die "Snippet not found: $name"
  fi

  msg "$CYAN" "Snippet: $name"
  echo ""
  cat "$snippet_file"
}

# Add prompt from snippet
add_from_snippet() {
  local name="$1"

  if [[ -z "$name" ]]; then
    die "Usage: promptq snippet add <name>"
  fi

  local snippet_file="${SNIPPETS}/${name}.txt"

  if [[ ! -f "$snippet_file" ]]; then
    die "Snippet not found: $name"
  fi

  # Read snippet content
  local content
  content=$(cat "$snippet_file")

  # Extract tags from the last line if it starts with #
  local text="$content"
  local tags=""
  local last_line
  last_line=$(echo "$content" | tail -1)

  if echo "$last_line" | grep -qE '^#[a-zA-Z0-9_-]+'; then
    tags="$last_line"
    # Remove last line from content (portable way)
    text=$(echo "$content" | sed '$d')
  fi

  # Add to queue
  add_prompt "$text" "$tags"
}

# Edit a template (or select with fzf if no name provided)
# Usage: edit_template [name]
edit_template() {
  local name="$1"

  # If no name provided, use fzf to select
  if [[ -z "$name" ]]; then
    mkdir -p "$TEMPLATES"

    if [[ ! -d "$TEMPLATES" ]] || [[ -z "$(ls -A "$TEMPLATES" 2>/dev/null)" ]]; then
      msg "$YELLOW" "No templates found in $TEMPLATES"
      return 1
    fi

    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide template name: promptq template edit <name>"
    fi

    msg "$CYAN" "Select template to edit:"
    echo ""

    local selection
    if command -v bat &>/dev/null; then
      selection=$(cd "$TEMPLATES" && ls -1 *.tmpl 2>/dev/null | sed 's/\.tmpl$//' | fzf --height=40% --reverse --prompt="Template> " --preview "bat --color=always --style=numbers '$TEMPLATES/{}.tmpl'" --preview-window=right:60%:wrap)
    else
      selection=$(cd "$TEMPLATES" && ls -1 *.tmpl 2>/dev/null | sed 's/\.tmpl$//' | fzf --height=40% --reverse --prompt="Template> " --preview "cat '$TEMPLATES/{}.tmpl'" --preview-window=right:60%:wrap)
    fi

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No template selected."
      return 1
    fi

    name="$selection"
  fi

  # Check if chezmoi is available
  if command -v chezmoi &>/dev/null; then
    local template_path="~/.config/promptq/templates/${name}.tmpl"
    msg "$CYAN" "Opening template in chezmoi..."

    if chezmoi edit "$template_path"; then
      msg "$GREEN" "Template edited successfully"
      msg "$BLUE" "Run 'chezmoi apply' to apply changes, or use 'chezmoi diff' to see what will change"
    else
      die "Failed to edit template with chezmoi"
    fi
  else
    # Fallback: direct edit with warning
    local template_file="${TEMPLATES}/${name}.tmpl"

    if [[ ! -f "$template_file" ]]; then
      die "Template not found: $name"
    fi

    msg "$YELLOW" "Warning: Editing template directly (not using chezmoi)"
    msg "$YELLOW" "    Changes may be overwritten if template is managed by chezmoi"
    echo ""

    local editor
    editor=$(get_editor)

    if "$editor" "$template_file"; then
      msg "$GREEN" "Template edited"
    else
      die "Editor exited with error"
    fi
  fi
}

# Edit a snippet (or select with fzf if no name provided)
# Usage: edit_snippet [name]
edit_snippet() {
  local name="$1"

  # If no name provided, use fzf to select
  if [[ -z "$name" ]]; then
    mkdir -p "$SNIPPETS"

    if [[ ! -d "$SNIPPETS" ]] || [[ -z "$(ls -A "$SNIPPETS" 2>/dev/null)" ]]; then
      msg "$YELLOW" "No snippets found in $SNIPPETS"
      return 1
    fi

    if ! command -v fzf &>/dev/null; then
      die "fzf is not installed. Please provide snippet name: promptq snippet edit <name>"
    fi

    msg "$CYAN" "Select snippet to edit:"
    echo ""

    local selection
    if command -v bat &>/dev/null; then
      selection=$(cd "$SNIPPETS" && ls -1 *.txt 2>/dev/null | sed 's/\.txt$//' | fzf --height=40% --reverse --prompt="Snippet> " --preview "bat --color=always --style=numbers '$SNIPPETS/{}.txt'" --preview-window=right:60%:wrap)
    else
      selection=$(cd "$SNIPPETS" && ls -1 *.txt 2>/dev/null | sed 's/\.txt$//' | fzf --height=40% --reverse --prompt="Snippet> " --preview "cat '$SNIPPETS/{}.txt'" --preview-window=right:60%:wrap)
    fi

    if [[ -z "$selection" ]]; then
      msg "$YELLOW" "No snippet selected."
      return 1
    fi

    name="$selection"
  fi

  # Check if chezmoi is available
  if command -v chezmoi &>/dev/null; then
    local snippet_path="~/.config/promptq/snippets/${name}.txt"
    msg "$CYAN" "Opening snippet in chezmoi..."

    if chezmoi edit "$snippet_path"; then
      msg "$GREEN" "Snippet edited successfully"
      msg "$BLUE" "Run 'chezmoi apply' to apply changes, or use 'chezmoi diff' to see what will change"
    else
      die "Failed to edit snippet with chezmoi"
    fi
  else
    # Fallback: direct edit with warning
    local snippet_file="${SNIPPETS}/${name}.txt"

    if [[ ! -f "$snippet_file" ]]; then
      die "Snippet not found: $name"
    fi

    msg "$YELLOW" "Warning: Editing snippet directly (not using chezmoi)"
    msg "$YELLOW" "    Changes may be overwritten if snippet is managed by chezmoi"
    echo ""

    local editor
    editor=$(get_editor)

    if "$editor" "$snippet_file"; then
      msg "$GREEN" "Snippet edited"
    else
      die "Editor exited with error"
    fi
  fi
}

# =============================================================================
# Send Functions
# =============================================================================

# Detect Coding Assistants pane in tmux
detect_claude_pane() {
  command -v tmux >/dev/null 2>&1 || return 1
  tmux list-sessions >/dev/null 2>&1 || return 1

  # helper: verify pane exists
  _exists() { tmux list-panes -a -F '#{pane_id}' 2>/dev/null | grep -qx "$1"; }

  # Priority 1: Use PROMPTQ_PANE environment variable if set
  if [[ -n "${PROMPTQ_PANE:-}" ]] && _exists "$PROMPTQ_PANE"; then
    echo "$PROMPTQ_PANE"
    return 0
  fi

  # Priority 2: Check config file for target_pane
  if [[ -f "$CONFIG" ]]; then
    local config_pane
    config_pane=$(grep -E '^target_pane=' "$CONFIG" 2>/dev/null | cut -d= -f2)
    if [[ -n "$config_pane" ]] && _exists "$config_pane"; then
      echo "$config_pane"
      return 0
    fi
  fi

  local pane_id=""

  # Priority 3: Current window, @role=claude (most specific)
  if [[ -n "${TMUX:-}" ]]; then
    local wid
    wid=$(tmux display -p '#{window_id}' 2>/dev/null)
    pane_id=$(
      tmux list-panes -F '#{window_id} #{pane_id} #{?@role,#{@role},-}' 2>/dev/null \
      | awk -v wid="$wid" 'tolower($1)==tolower(wid) && tolower($3)=="claude" {print $2; exit}'
    )
    if [[ -n "$pane_id" ]]; then
      echo "$pane_id"
      return 0
    fi
  fi

  # Priority 4: Any window, @role=claude (stable tag-based detection)
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{?@role,#{@role},-}' 2>/dev/null \
    | awk 'tolower($2)=="claude" {print $1; exit}'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  # Priority 5: Fallback - title contains "Coding Assistants"
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{pane_title}' 2>/dev/null \
    | awk 'tolower($2) ~ /claude[[:space:]]+code/ {print $1; exit}'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  # Priority 6: Fallback - command/title contains "claude" (exclude claude-monitor)
  pane_id=$(
    tmux list-panes -a -F '#{pane_id} #{pane_current_command} #{pane_title}' 2>/dev/null \
    | awk 'BEGIN{IGNORECASE=1} $2 ~ /claude/ || $3 ~ /claude/ { if($2 !~ /claude-monitor/ && $3 !~ /claude-monitor/) {print $1; exit} }'
  )
  if [[ -n "$pane_id" ]]; then
    echo "$pane_id"
    return 0
  fi

  return 1
}

# Send text to Claude via tmux
send_via_tmux() {
  local text="$1"
  local pane_id="$2"

  # Send text to pane (use -l for literal text, no key interpretation)
  if tmux send-keys -t "$pane_id" -l "$text" 2>/dev/null; then
    # Send Enter key
    tmux send-keys -t "$pane_id" Enter 2>/dev/null
    return 0
  fi

  return 1
}

# Send text to clipboard
send_via_clipboard() {
  local text="$1"

  if command -v pbcopy &> /dev/null; then
    echo "$text" | pbcopy
    return 0
  elif command -v xclip &> /dev/null; then
    echo "$text" | xclip -selection clipboard
    return 0
  elif command -v xsel &> /dev/null; then
    echo "$text" | xsel --clipboard
    return 0
  fi

  return 1
}

# Send first prompt in queue (FIFO)
send_prompt() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "Queue is empty"
    return 0
  fi

  # Acquire lock before reading and modifying queue
  acquire_lock

  # Get first line
  local entry
  entry=$(head -1 "$QUEUE")
  local text
  text=$(echo "$entry" | jq -r '.text')
  local tags
  tags=$(echo "$entry" | jq -r '.tags[]' 2>/dev/null)

  # Check if #reusable tag is present (auto-keep)
  local should_keep="$KEEP_QUEUE"
  if echo "$tags" | grep -qx "reusable"; then
    should_keep="1"
  fi

  msg "$CYAN" "Sending: ${text:0:60}..."

  # Try tmux first
  local pane_id
  if pane_id=$(detect_claude_pane); then
    if send_via_tmux "$text" "$pane_id"; then
      msg "$GREEN" "Sent via tmux (pane: $pane_id)"

      # Add to sent log
      echo "$entry" >> "$SENT"

      # Remove from queue unless --keep flag is set or #reusable tag present
      if [[ "$should_keep" == "0" ]]; then
        tail -n +2 "$QUEUE" > "${QUEUE}.tmp" && mv "${QUEUE}.tmp" "$QUEUE"
        msg "$BLUE" "Remaining: $(count_queue) items"
      else
        msg "$BLUE" "Kept in queue ($(count_queue) items)"
      fi

      release_lock
      return 0
    fi
  else
    # If inside tmux but no claude found in current window
    if [[ -n "${TMUX:-}" ]]; then
      msg "$YELLOW" "Warning: No Claude pane found in current window"
      msg "$BLUE" "Hint: Open Claude in this window, or set target pane:"
      msg "$BLUE" "  promptq config set-pane <pane_id>"
    fi
  fi

  # Try clipboard
  if send_via_clipboard "$text"; then
    msg "$YELLOW" "Copied to clipboard (paste manually)"

    # Add to sent log
    echo "$entry" >> "$SENT"

    # Remove from queue unless --keep flag is set or #reusable tag present
    if [[ "$should_keep" == "0" ]]; then
      tail -n +2 "$QUEUE" > "${QUEUE}.tmp" && mv "${QUEUE}.tmp" "$QUEUE"
      msg "$BLUE" "Remaining: $(count_queue) items"
    else
      msg "$BLUE" "Kept in queue ($(count_queue) items)"
    fi

    release_lock
    return 0
  fi

  # Fallback: print to stdout
  msg "$RED" "Warning: Could not send automatically"
  msg "$YELLOW" "Please copy manually:"
  echo ""
  echo "$text"

  release_lock
  return 1
}

# Interactive send with fzf
select_and_send() {
  ensure_config

  local count
  count=$(count_queue)

  if [[ $count -eq 0 ]]; then
    msg "$YELLOW" "Queue is empty"
    return 0
  fi

  if ! command -v fzf &> /dev/null; then
    die "fzf is not installed. Install with: brew install fzf"
  fi

  # Format queue for fzf with safe preview
  # Create display format: index + truncated text + tags
  local display_lines
  display_lines=$(jq -r 'input_line_number as $n |
    ($n | tostring) + ". " +
    (.text | gsub("\n"; " ") | gsub("\\s+"; " ") | .[0:80]) +
    (if (.text | length) > 80 then "..." else "" end) +
    " " +
    (if (.tags | length) > 0 then (.tags | map("#" + .) | join(" ")) else "" end)' "$QUEUE")

  local selected_idx
  selected_idx=$(echo "$display_lines" | \
    fzf --height 50% \
        --reverse \
        --header "Select prompt to send (ESC to cancel)" \
        --preview "LINE=\$(echo {1} | tr -d '.'); sed -n \"\${LINE}p\" \"$QUEUE\" | jq -r '.text'" \
        --preview-window=up:3:wrap | \
    awk '{print $1}' | \
    tr -d '.')

  if [[ -z "$selected_idx" ]]; then
    msg "$YELLOW" "Cancelled"
    return 0
  fi

  # Acquire lock before reading and modifying queue
  acquire_lock

  # Get selected entry
  local entry
  entry=$(sed -n "${selected_idx}p" "$QUEUE")
  local text
  text=$(echo "$entry" | jq -r '.text')
  local tags
  tags=$(echo "$entry" | jq -r '.tags[]' 2>/dev/null)

  # Check if #reusable tag is present (auto-keep)
  local should_keep="$KEEP_QUEUE"
  if echo "$tags" | grep -qx "reusable"; then
    should_keep="1"
  fi

  msg "$CYAN" "Sending: ${text:0:60}..."

  # Try tmux first
  local pane_id
  if pane_id=$(detect_claude_pane); then
    if send_via_tmux "$text" "$pane_id"; then
      msg "$GREEN" "Sent via tmux (pane: $pane_id)"

      # Add to sent log
      echo "$entry" >> "$SENT"

      # Remove from queue unless --keep flag is set or #reusable tag present
      if [[ "$should_keep" == "0" ]]; then
        sed -i '' "${selected_idx}d" "$QUEUE"
        msg "$BLUE" "Remaining: $(count_queue) items"
      else
        msg "$BLUE" "Kept in queue ($(count_queue) items)"
      fi

      release_lock
      return 0
    fi
  else
    # If inside tmux but no claude found in current window
    if [[ -n "${TMUX:-}" ]]; then
      msg "$YELLOW" "Warning: No Claude pane found in current window"
      msg "$BLUE" "Hint: Open Claude in this window, or set target pane:"
      msg "$BLUE" "  promptq config set-pane <pane_id>"
    fi
  fi

  # Try clipboard
  if send_via_clipboard "$text"; then
    msg "$YELLOW" "Copied to clipboard (paste manually)"

    # Add to sent log
    echo "$entry" >> "$SENT"

    # Remove from queue unless --keep flag is set or #reusable tag present
    if [[ "$should_keep" == "0" ]]; then
      sed -i '' "${selected_idx}d" "$QUEUE"
      msg "$BLUE" "Remaining: $(count_queue) items"
    else
      msg "$BLUE" "Kept in queue ($(count_queue) items)"
    fi

    release_lock
    return 0
  fi

  # Fallback: print to stdout
  msg "$RED" "Warning: Could not send automatically"
  msg "$YELLOW" "Please copy manually:"
  echo ""
  echo "$text"

  release_lock
  return 1
}

# =============================================================================
# Main CLI
# =============================================================================

show_help() {
  if has_gum; then
    # Rich help with gum (optimized: 4 gum calls instead of 17, 56% faster)

    # Header (1 gum call)
    gum style \
      --foreground 212 \
      --border double \
      --border-foreground 212 \
      --align center \
      --width 70 \
      --margin "1 0" \
      --padding "1 2" \
      --bold \
      "promptq" \
      "Prompt Queue Manager for Coding Assistants"

    echo ""
    # Use printf with ANSI codes instead of gum for simple headers
    printf "\033[1m\033[38;5;99mUSAGE\033[0m\n"
    echo "  promptq [--plain] [--keep] <command> [arguments]"
    echo ""
    printf "\033[1m\033[38;5;99mGLOBAL FLAGS\033[0m\n"
    echo "  --plain, -p    Disable styling (script-friendly output)"
    echo "  --keep, -k     Keep items in queue after sending (reusable prompts)"
    echo ""

    printf "\033[1m\033[38;5;99mCOMMANDS\033[0m\n"
    # Commands table (1 gum call)
    {
      echo "Command|Arguments|Description"
      echo "add|<text> [#tags]|Add prompt to queue with optional tags"
      echo "list|─|List all queued prompts"
      echo "edit|[number]|Edit a queue item (fzf if no number)"
      echo "delete|[numbers...]|Delete items (fzf multi-select if no args)"
      echo "tag-add|[num] [tags...]|Add tags (fzf if no args)"
      echo "tag-remove|[num] [tags...]|Remove tags (fzf if no args)"
      echo "count|─|Show queue size"
      echo "send|─|Send first prompt (FIFO, keeps #reusable)"
      echo "select-send|─|Interactive send with fzf (keeps #reusable)"
      echo "filter|<#tag>|Filter prompts by tag"
      echo "tags|─|List all tags with counts"
      echo "template list|─|List available templates"
      echo "template show|[name]|Show template content (fzf if no name)"
      echo "template add|<name> ...|Add from template with vars"
      echo "template edit|[name]|Edit a template (fzf if no name)"
      echo "snippet list|─|List available snippets"
      echo "snippet show|[name]|Show snippet content (fzf if no name)"
      echo "snippet add|<name>|Add from snippet"
      echo "snippet edit|[name]|Edit a snippet (fzf if no name)"
      echo "config set-pane|<pane>|Set target tmux pane"
      echo "config show-pane|─|Show current target pane"
      echo "clear|─|Clear all queued prompts"
      echo "help|─|Show this help"
      echo "version|─|Show version"
    } | gum table --separator "|" --border rounded --border.foreground 240 --print --widths "20,15,40"

    echo ""
    printf "\033[1m\033[38;5;99mEXAMPLES\033[0m\n"
    echo ""

    # Consolidated examples using printf with ANSI codes (faster than multiple gum calls)
    printf "  \033[1m\033[38;5;99mAdding prompts:\033[0m\n"
    printf "\033[38;5;240m    \$ promptq add \"Explain async/await in JavaScript\"\033[0m\n"
    printf "\033[38;5;240m    \$ promptq add \"Review this PR\" #review #urgent\033[0m\n"
    echo ""
    printf "  \033[1m\033[38;5;99mEditing content:\033[0m\n"
    printf "\033[38;5;240m    \$ promptq edit 1                      # Edit queue item\033[0m\n"
    printf "\033[38;5;240m    \$ promptq delete                      # Delete with fzf (TAB for multi-select)\033[0m\n"
    printf "\033[38;5;240m    \$ promptq delete 1 3 5                # Delete specific items\033[0m\n"
    printf "\033[38;5;240m    \$ promptq template edit code-review   # Edit template\033[0m\n"
    printf "\033[38;5;240m    \$ promptq snippet edit daily-standup  # Edit snippet\033[0m\n"
    echo ""
    printf "  \033[1m\033[38;5;99mSending prompts:\033[0m\n"
    printf "\033[38;5;240m    \$ promptq send                        # Send first (deletes unless #reusable)\033[0m\n"
    printf "\033[38;5;240m    \$ promptq --keep send                 # Keep in queue\033[0m\n"
    printf "\033[38;5;240m    \$ promptq select-send                 # Interactive send\033[0m\n"
    echo ""
    printf "  \033[1m\033[38;5;99mTag management:\033[0m\n"
    printf "\033[38;5;240m    \$ promptq tag-add                     # Interactive: select item, input tags\033[0m\n"
    printf "\033[38;5;240m    \$ promptq tag-add 1 reusable urgent   # Direct: add tags to item\033[0m\n"
    printf "\033[38;5;240m    \$ promptq tag-remove                  # Interactive: select item, select tags\033[0m\n"
    printf "\033[38;5;240m    \$ promptq tag-remove 1 urgent         # Direct: remove tags from item\033[0m\n"
    printf "\033[38;5;240m    \$ promptq filter #rust\033[0m\n"
    printf "\033[38;5;240m    \$ promptq tags\033[0m\n"
    echo ""
    printf "  \033[1m\033[38;5;99mTemplates and snippets:\033[0m\n"
    printf "\033[38;5;240m    \$ promptq template list\033[0m\n"
    printf "\033[38;5;240m    \$ promptq template add explain-concept CONCEPT=\"async/await\" LANGUAGE=\"rust\"\033[0m\n"
    printf "\033[38;5;240m    \$ promptq snippet add daily-standup\033[0m\n"

    echo ""
    printf "\033[1m\033[38;5;99mLOCATIONS\033[0m\n"
    # Locations (1 gum call)
    gum style --border rounded --border-foreground 57 --padding "0 2" \
      "Queue:     ~/.config/promptq/queue.jsonl" \
      "Templates: ~/.config/promptq/templates/" \
      "Snippets:  ~/.config/promptq/snippets/"

    echo ""
    # Tip (1 gum call)
    gum style --foreground 240 --italic "Tip: Use --plain flag for script-friendly output"
  else
    # Fallback: simple text
    cat << 'EOF'
promptq - Prompt Queue Manager for Code Assistants

Usage:
  promptq [--plain] [--keep] <command> [arguments]

Commands:
  add <text> [#tags]        Add prompt to queue
  list                      List all queued prompts
  edit [number]             Edit a queue item (fzf if no number)
  count                     Show queue size
  send                      Send first prompt (FIFO)
  select-send               Interactive send with fzf
  filter <#tag>             Filter prompts by tag
  tags                      List all tags with counts
  template list             List available templates
  template show [name]      Show template content (fzf if no name)
  template add <name> ...   Add prompt from template
  template edit [name]      Edit a template (fzf if no name)
  snippet list              List available snippets
  snippet show [name]       Show snippet content (fzf if no name)
  snippet add <name>        Add prompt from snippet
  snippet edit [name]       Edit a snippet (fzf if no name)
  config set-pane <pane>    Set target tmux pane
  config show-pane          Show current target pane
  clear                     Clear all queued prompts
  help                      Show this help
  version                   Show version

Examples:
  promptq add "Explain async/await in JavaScript"
  promptq add "Review this PR" #review #urgent
  promptq edit 1
  promptq send
  promptq select-send
  promptq filter #rust
  promptq template add explain-concept CONCEPT="async/await" LANGUAGE="rust"
  promptq template edit explain-concept
  promptq snippet edit daily-standup

Locations:
  Queue:     ~/.config/promptq/queue.jsonl
  Templates: ~/.config/promptq/templates/
  Snippets:  ~/.config/promptq/snippets/

Send Priority:
  1. tmux send-keys (auto-detected Claude pane)
  2. Clipboard copy (pbcopy)
  3. Manual output to terminal
EOF
  fi
}

main() {
  # Parse global flags before command
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --plain|-p)
        PLAIN_OUTPUT=1
        shift
        ;;
      --keep|-k)
        KEEP_QUEUE=1
        shift
        ;;
      -*)
        msg "$RED" "Unknown flag: $1"
        echo ""
        show_help
        exit 1
        ;;
      *)
        break  # Not a flag, proceed to command
        ;;
    esac
  done

  local cmd="${1:-help}"

  case "$cmd" in
    add|a)
      shift
      if [[ $# -eq 0 ]]; then
        die "Usage: promptq add <text> [#tags]"
      fi

      local text="$1"
      shift
      local tags="$*"

      add_prompt "$text" "$tags"
      ;;

    list|ls|l)
      list_queue
      ;;

    count|c)
      echo "$(count_queue)"
      ;;

    send|s)
      send_prompt
      ;;

    select-send|ss)
      select_and_send
      ;;

    filter|f)
      shift
      if [[ $# -eq 0 ]]; then
        die "Usage: promptq filter #tag"
      fi
      filter_by_tag "$1"
      ;;

    tags|t)
      list_tags
      ;;

    edit|e)
      shift
      # Allow edit without number (fzf selection)
      edit_queue_item "${1:-}"
      ;;

    delete|del|d)
      shift
      delete_queue_item "$@"
      ;;

    tag-add|ta)
      shift
      tag_add_to_item "$@"
      ;;

    tag-remove|tag-rm|tr)
      shift
      tag_remove_from_item "$@"
      ;;

    template|tmpl)
      shift
      local subcmd="${1:-list}"
      shift || true

      case "$subcmd" in
        list|ls|l)
          list_templates
          ;;
        show|s)
          # Allow show without name (fzf selection)
          show_template "${1:-}"
          ;;
        add|a)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq template add <name> [VAR=value ...]"
          fi
          add_from_template "$@"
          ;;
        edit|e)
          # Allow edit without name (fzf selection)
          edit_template "${1:-}"
          ;;
        *)
          msg "$RED" "Unknown template command: $subcmd"
          msg "$YELLOW" "Available: list, show, add, edit"
          exit 1
          ;;
      esac
      ;;

    snippet|snip)
      shift
      local subcmd="${1:-list}"
      shift || true

      case "$subcmd" in
        list|ls|l)
          list_snippets
          ;;
        show|s)
          # Allow show without name (fzf selection)
          show_snippet "${1:-}"
          ;;
        add|a)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq snippet add <name>"
          fi
          add_from_snippet "$1"
          ;;
        edit|e)
          # Allow edit without name (fzf selection)
          edit_snippet "${1:-}"
          ;;
        *)
          msg "$RED" "Unknown snippet command: $subcmd"
          msg "$YELLOW" "Available: list, show, add, edit"
          exit 1
          ;;
      esac
      ;;

    config|cfg)
      shift
      local subcmd="${1:-}"
      shift || true

      case "$subcmd" in
        set-pane|sp)
          if [[ $# -eq 0 ]]; then
            die "Usage: promptq config set-pane <pane_id>"
          fi
          ensure_config
          echo "target_pane=$1" > "$CONFIG"
          msg "$GREEN" "Target pane set to: $1"
          msg "$BLUE" "Verify with: promptq config show-pane"
          ;;
        show-pane|gp)
          if detect_claude_pane > /dev/null; then
            local pane
            pane=$(detect_claude_pane)
            msg "$CYAN" "Target pane: $pane"

            # Show pane details
            local pane_info
            pane_info=$(tmux list-panes -a -F '#{pane_id} #{pane_title} #{pane_current_command}' 2>/dev/null | command grep "^$pane ")
            if [[ -n "$pane_info" ]]; then
              msg "$BLUE" "   $pane_info"
            fi
          else
            msg "$RED" "No Coding Assistants pane detected"
            msg "$YELLOW" "Set manually with: promptq config set-pane <pane_id>"
            msg "$YELLOW" "List panes: tmux list-panes -a"
          fi
          ;;
        *)
          msg "$RED" "Unknown config command: $subcmd"
          msg "$YELLOW" "Available: set-pane, show-pane"
          exit 1
          ;;
      esac
      ;;

    clear|clr)
      clear_queue
      ;;

    help|h|-h|--help)
      show_help
      ;;

    version|v|-v|--version)
      echo "promptq v${VERSION}"
      ;;

    *)
      msg "$RED" "Unknown command: $cmd"
      echo ""
      show_help
      exit 1
      ;;
  esac
}

main "$@"
