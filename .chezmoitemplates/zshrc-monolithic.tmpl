# ============================================================================
# Performance Profiling (uncomment when benchmarking)
# ============================================================================
# zmodload zsh/zprof

# ============================================================================
# Core Initialization
# ============================================================================

# --- Homebrew ---
{{- if eq .chezmoi.os "darwin" }}
{{-   if eq .chezmoi.arch "arm64" }}
export HOMEBREW_PREFIX="/opt/homebrew"
export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
export HOMEBREW_REPOSITORY="/opt/homebrew"
fpath[1,0]="/opt/homebrew/share/zsh/site-functions"

# PATH_HELPER optimization: Cache output to avoid spawning process every time (saves 5-15ms)
# Regenerate cache only if /etc/paths or /etc/paths.d/* change
typeset -g _PATH_HELPER_CACHE="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/path_helper.zsh"
if [[ ! -f "$_PATH_HELPER_CACHE" ]] || \
   [[ /etc/paths -nt "$_PATH_HELPER_CACHE" ]] || \
   [[ -d /etc/paths.d && /etc/paths.d -nt "$_PATH_HELPER_CACHE" ]]; then
  mkdir -p "${_PATH_HELPER_CACHE:h}"
  /usr/bin/env PATH_HELPER_ROOT="/opt/homebrew" /usr/libexec/path_helper -s > "$_PATH_HELPER_CACHE" 2>/dev/null
fi
[[ -f "$_PATH_HELPER_CACHE" ]] && source "$_PATH_HELPER_CACHE"

[ -z "${MANPATH-}" ] || export MANPATH=":${MANPATH#:}"
export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}"
{{-   else }}
# macOS x86_64
if [[ -x "/usr/local/bin/brew" ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
  HOMEBREW_PREFIX="/usr/local"
fi
{{-   end }}
{{- else }}
# Linux (including Codespaces/DevContainers)
if [[ -x "/home/linuxbrew/.linuxbrew/bin/brew" ]]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
{{- end }}

# --- Prompt ---
export PROMPT_THEME="${PROMPT_THEME:-p10k}"

if [[ "$PROMPT_THEME" == "p10k" ]]; then
  # Bypass P10k SSH detection for local sessions (saves 12-20ms)
  # Sets both P9K_SSH and _P9K_SSH_TTY to trigger early-exit in _p9k_init_ssh
  # The function will still run for new TTYs (e.g., actual SSH sessions)
  # Reference: https://github.com/romkatv/powerlevel10k/pull/2774
  typeset -gix P9K_SSH=0
  typeset -gx _P9K_SSH_TTY=$TTY

  if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
  fi
fi

if [[ "$PROMPT_THEME" == "starship" ]]; then
  eval "$(starship init zsh)"
  export STARSHIP_CONFIG=~/.config/starship.toml
elif [[ "$PROMPT_THEME" == "p10k" ]]; then
  source ~/powerlevel10k/powerlevel10k.zsh-theme
  [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
fi

# ============================================================================
# Tool Configuration
# ============================================================================

# --- FZF ---
# FZF environment variables deferred - set before key bindings load
# (saves ~1ms at startup)

# --- zsh-autosuggestions ---
export ZSH_AUTOSUGGEST_MANUAL_REBIND=1
export ZSH_AUTOSUGGEST_USE_ASYNC=1
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'  # Gray color for suggestions
export ZSH_AUTOSUGGEST_STRATEGY=(history completion)

# --- sheldon (plugin manager with cache) ---
if command -v sheldon >/dev/null 2>&1; then
  _sheldon_cache="${XDG_CACHE_HOME:-$HOME/.cache}/sheldon/sheldon.zsh"
  _sheldon_toml="${XDG_CONFIG_HOME:-$HOME/.config}/sheldon/plugins.toml"
  if [[ ! -r "$_sheldon_cache" || "$_sheldon_toml" -nt "$_sheldon_cache" ]]; then
    mkdir -p "${_sheldon_cache:h}"
    sheldon source > "$_sheldon_cache"
  fi
  source "$_sheldon_cache"
  unset _sheldon_cache _sheldon_toml
else
  echo "Warning: sheldon not found. Plugins will not be loaded." >&2
  echo "Install with: brew install sheldon" >&2
fi

# --- Completion system (cached, deferred) ---
_load_completion() {
  autoload -Uz compinit
  local _comp_path="${ZDOTDIR:-$HOME}/.zcompdump"
  if [[ -n $_comp_path(#qNmh-24) ]]; then
    compinit -C -u -d "$_comp_path"
  else
    compinit -u -d "$_comp_path"
  fi
}
zsh-defer _load_completion

# --- mise shims (immediate, for non-interactive shells like Zellij) ---
# Must be loaded BEFORE zsh-defer to ensure tools are available immediately
# in non-interactive contexts (Zellij panes, IDEs, scripts)
# Optimization: Direct PATH export if not already loaded by .zprofile (saves ~5ms)
# .zprofile already sets MISE_SHELL, so this is mostly for non-login shells
if [[ -z "${MISE_SHELL:-}" ]] && command -v mise >/dev/null 2>&1; then
  export PATH="{{ .chezmoi.homeDir }}/.local/share/mise/shims:$PATH"
  export MISE_SHELL=zsh
fi

# --- Deferred tool initialization ---
zsh-defer -c 'export _ZO_FZF_OPTS="--height 40% --layout=reverse --border --preview \"eza --icons --color=always {2..}\""'
zsh-defer -c 'eval "$(zoxide init --cmd j zsh)"'
zsh-defer -c 'eval "$(atuin init zsh)"'
# mise activate (full features) - deferred for interactive shells
# Note: mise shims are already loaded above for immediate PATH access
zsh-defer -c 'eval "$(mise activate zsh)"'

# --- FZF key bindings ---
if [[ -f "${HOMEBREW_PREFIX}/opt/fzf/shell/key-bindings.zsh" ]]; then
  zsh-defer -c 'export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow --exclude .git"
export FZF_DEFAULT_OPTS="--height 40% --layout=reverse --border --preview \"bat --color=always --style=numbers --line-range=:500 {}\""
source "${HOMEBREW_PREFIX}/opt/fzf/shell/key-bindings.zsh"'
fi
if [[ -f "${HOMEBREW_PREFIX}/opt/fzf/shell/completion.zsh" ]]; then
  zsh-defer source "${HOMEBREW_PREFIX}/opt/fzf/shell/completion.zsh"
fi

# --- Amazon Q (deferred, optional) ---
# zsh-defer -c '[[ -f "${HOME}/Library/Application Support/amazon-q/shell/zshrc.pre.zsh" ]] && builtin source "${HOME}/Library/Application Support/amazon-q/shell/zshrc.pre.zsh"'
zsh-defer -c '[[ -f "${HOME}/Library/Application Support/amazon-q/shell/zshrc.post.zsh" ]] && builtin source "${HOME}/Library/Application Support/amazon-q/shell/zshrc.post.zsh"'

# ============================================================================
# Environment Variables
# ============================================================================

# --- Helper function: Add to PATH only if not present ---
_add_to_path_prepend() {
  [[ ":$PATH:" != *":$1:"* ]] && export PATH="$1:$PATH"
}

_add_to_path_append() {
  [[ ":$PATH:" != *":$1:"* ]] && export PATH="$PATH:$1"
}

# --- Deferred PATH additions ---
# These development tools are rarely needed immediately at shell startup
_setup_dev_paths() {
  _add_to_path_prepend "{{ .chezmoi.homeDir }}/.slack/bin"
  # Cargo bin already added in .zshenv via '. "$HOME/.cargo/env"'
  _add_to_path_prepend "${HOMEBREW_PREFIX}/opt/gnu-time/libexec/gnubin"
  _add_to_path_prepend "${HOMEBREW_PREFIX}/opt/llvm/bin"

  # Alacritty custom scripts (toggle_opacity, etc.)
  _add_to_path_append "{{ .chezmoi.homeDir }}/.config/alacritty/bin"
}
zsh-defer _setup_dev_paths

# --- C++ Development (LLVM/Clang) ---
# Deferred to save ~2ms at startup - only loaded when needed
_setup_cpp_env() {
  export CC="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
  export CXX="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
  export SDKROOT="/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
  export CFLAGS="-isysroot ${SDKROOT}"
  export CXXFLAGS="-isysroot ${SDKROOT}"
  export LDFLAGS="-L${HOMEBREW_PREFIX}/opt/llvm/lib/c++ -Wl,-rpath,${HOMEBREW_PREFIX}/opt/llvm/lib/c++"
}
# Defer C++ environment setup - will be loaded after prompt
zsh-defer _setup_cpp_env

# ============================================================================
# GitHub Integration (1Password)
# ============================================================================
# Fallback pattern: env variable → chezmoi data → 1Password
# GITHUB_TOKEN is used by: gh CLI, git, chezmoi GitHub functions, GitHub Copilot CLI
{{- if or (env "GITHUB_TOKEN") .github_token }}
export GITHUB_TOKEN="{{ or (env "GITHUB_TOKEN") .github_token }}"
{{- end }}

# ============================================================================
# Aliases
# ============================================================================

# --- Editor ---
alias vim='nvim'
alias vi='nvim'
alias v='nvim'

# --- File operations (eza) ---
# Default aliases: Fast (no --git flag)
# Optimization: --git adds 10-100ms overhead scanning git status per file
alias e='eza --icons --sort=type'
alias l=e
alias ls=e
alias ea='eza -a --icons --sort=type'
alias la=ea
alias ee='eza -aahl --icons --sort=type'
alias ll=ee

# Git-aware versions (explicit, when you need git status)
alias eg='eza --icons --git --sort=type'
alias eag='eza -a --icons --git --sort=type'
alias eeg='eza -aahl --icons --git --sort=type'
alias et='eza -T -L 3 -a -I "node_modules|.git|.cache" --icons --sort=type'
alias lt=et
alias eta='eza -T -a -I "node_modules|.git|.cache" --color=always --icons --sort=type | less -r'
alias lta=eta

# --- Modern CLI tools ---
alias cat='bat --paging=never'
alias less='bat'
alias grep='rg -S'
alias -g G='| rg -S'
alias top='btm'
alias bottom='btm'
alias du='dust'
alias df='duf'
alias ps='procs --tree'
alias rm='trash'

# --- Navigation ---
alias d='cd ~/Documents'
alias dot='cd ~/.local/share/chezmoi'
alias obs='cd ~/Google\ Drive/My\ Drive/obsidian/'
alias ..1='cd ../'
alias ..2='cd ../../'
alias ..3='cd ../../../'
alias ..4='cd ../../../../'

# --- History ---
alias h1='history -100 | tail -r | bat -l sh'
alias h10='history -1000 | tail -r | bat -l sh'

# --- Multiplexer Workspaces (abstracted) ---
alias twork='mux-work'       # Multiplexer-agnostic (was tmux-work)
alias tw='mux-work'          # Short form
alias tcc='mux-claude'       # Multiplexer-agnostic (was tmux-claude)
alias tc='mux-claude'        # Short form
alias tvim='mux-nvim'        # Multiplexer-agnostic (was tmux-nvim)
alias tv='mux-nvim'          # Short form
alias tnu='mux-nu'           # Multiplexer-agnostic (was tmux-nu)
alias tn='mux-nu'            # Short form
alias twk='mux-kill-window'  # Multiplexer-agnostic window kill

# --- Tmux-specific (when you explicitly need tmux) ---
alias tmux-health='tmux list-panes -a -F "Pane #{pane_id}: #{history_size}/#{history_limit} lines"'

# --- Nushell ---
alias nu='nu'
alias nuscript='nu -c'
alias vnu='chezmoi edit ~/.config/nushell/config.nu'

# --- Chezmoi ---
alias vzsh='chezmoi edit ~/.zshrc'
alias vbrew='chezmoi edit ~/.Brewfile'
alias szsh='source ~/.zshrc'
alias cdot='chezmoi cd'
alias adot='chezmoi apply'

# --- Claude Code ---
alias ai='claude'
alias ppq='promptq'

# --- Git ---
alias lg='gitui'
alias ld='lazydocker'

# --- Repository shortcuts ---
# These now use mux-nvim (multiplexer-agnostic)
alias rt='repo -t'          # repo with multiplexer (1 pane)
alias rt2='repo -t2'        # repo with multiplexer (2 panes)
alias rtd='repo -t2'        # repo with multiplexer (dual panes)
alias mr='mux-repo'         # direct mux-repo call
alias mr2='mux-repo --dual' # direct mux-repo call (2 panes)

# --- Additional productivity aliases ---
alias tree='eza --tree'
alias dig='doggo'
alias http='xh'
alias man='tldr'
alias watch='viddy'
alias find='fd'
alias sed='sd'

# --- pueue task queue ---
alias pq='pueue'
alias pqa='pueue add'
alias pqs='pueue status'
alias pql='pueue log'
alias pqc='pueue clean'

# --- ouch compression ---
alias compress='ouch compress'
alias decompress='ouch decompress'
alias archive='ouch compress'
alias extract='ouch decompress'

# --- Misc ---
alias c='clear'
alias cl='tty-clock -sc'
alias tenki='http wttr.in/Tokyo'
alias zsh-bench='for i in $(seq 1 20); do time zsh -i -c exit; done'

# ============================================================================
# Functions - Utilities
# ============================================================================

# zoxide interactive mode
# Usage: zi [keyword]
# Note: Wrapper for __zoxide_zi (must be a function to work with zsh-defer)
zi() {
  __zoxide_zi "$@"
}

# 1Password sign in
# Usage: ops
ops() {
  eval $(op signin)
}

# Cheat sheet viewer (navi + tldr)
# Usage:
#   ch           - Interactive navi (all cheatsheets)
#   ch <command> - Interactive navi with query
#   cht <command> - Direct tldr lookup (non-interactive)
ch() {
  if [[ $# -eq 0 ]]; then
    navi
  else
    navi --query "$*"
  fi
}
# Direct tldr lookup (non-interactive)
cht() { navi --tldr "$*" }
# Legacy cheat implementation (uncomment if needed):
# ch() { cheat $* | bat -l sh }

# Code search with bat
agg() { ag $* | bat -l sh }

# JSON grep
jgrep() { jq | gron | grep $* | gron -u }

# History utilities
hg() { history -1000 | grep $* | tail -r | bat -l sh }
hc() { history -1000 | awk -v cmd="$1" '$1 == cmd { $1=""; sub(/^ +/, ""); print; exit }' | tr -d '\n' | pbcopy }

# Claude ask with multi-line support
ask() {
  if [[ $# -eq 0 ]]; then
    echo "Enter your prompt (press Ctrl+D on a new line to finish):"
    local input="$(cat)"
    [[ -n "$input" ]] && claude -p "$input"
  else
    claude -p "$*"
  fi
}

# ============================================================================
# Functions - Shell Management
# ============================================================================

# ============================================================================
# Multiplexer Abstraction Layer
# ============================================================================
# Detect current multiplexer from chezmoi config
# Returns: "tmux" or "zellij" (defaults to tmux)
get-multiplexer() {
  # Environment variable override
  if [[ -n "${MULTIPLEXER:-}" ]]; then
    echo "$MULTIPLEXER"
    return 0
  fi

  # Read from chezmoi config
  local chezmoi_config="${HOME}/.config/chezmoi/chezmoi.toml"
  if [[ -f "$chezmoi_config" ]]; then
    local mux=$(grep -A 1 '^\[data\.zsh\]' "$chezmoi_config" 2>/dev/null | \
                grep 'multiplexer' | \
                command sed 's/.*"\(.*\)".*/\1/')
    if [[ -n "$mux" ]]; then
      echo "$mux"
      return 0
    fi
  fi

  # Default to tmux
  echo "tmux"
}

# Check if running inside a multiplexer
in-multiplexer() {
  [[ -n "${TMUX:-}" || -n "${ZELLIJ:-}" ]]
}

# Get current multiplexer type (when inside one)
current-multiplexer() {
  if [[ -n "${TMUX:-}" ]]; then
    echo "tmux"
  elif [[ -n "${ZELLIJ:-}" ]]; then
    echo "zellij"
  else
    echo "none"
  fi
}

# Kill current window (abstracted)
mux-kill-window() {
  local mux=$(current-multiplexer)
  case "$mux" in
    tmux)
      local id
      id="$(tmux display -p '#{window_id}' 2>/dev/null)" || {
        echo "Run inside tmux session" >&2; return 1
      }
      tmux kill-window -t "$id"
      ;;
    zellij)
      zellij action close-tab
      ;;
    *)
      echo "Not inside a multiplexer session" >&2
      return 1
      ;;
  esac
}

# Note: twk is now an alias to mux-kill-window (see aliases section above)

# Clear zsh caches and restart
zsh-refresh() {
  echo "Clearing sheldon cache..."
  command rm -f "${XDG_CACHE_HOME:-$HOME/.cache}/sheldon/sheldon.zsh"
  echo "Clearing completion cache..."
  command rm -f "${ZDOTDIR:-$HOME}/.zcompdump"
  echo "Restarting zsh..."
  exec zsh
}

# Switch between Starship and Powerlevel10k
switch-prompt() {
  local theme="${1:-}"
  local zshenv_local="${ZDOTDIR:-$HOME}/.zshenv.local"

  if [[ -z "$theme" ]]; then
    echo "Current prompt: $PROMPT_THEME"
    echo ""
    echo "Usage: switch-prompt [starship|p10k]"
    echo ""
    echo "Performance (zsh-bench):"
    echo "  P10k:     first_prompt=45.9ms, command=42.9ms  (faster)"
    echo "  Starship: first_prompt=83.5ms, command=83.8ms  (cross-shell)"
    return 0
  fi

  if [[ "$theme" != "starship" && "$theme" != "p10k" ]]; then
    echo "Error: theme must be 'starship' or 'p10k'" >&2
    return 1
  fi

  echo "# Prompt theme override (managed by switch-prompt command)" > "$zshenv_local"
  echo "export PROMPT_THEME=$theme" >> "$zshenv_local"

  echo "✅ Prompt switched to: $theme"
  echo "📝 Saved to: ~/.zshenv.local (not in chezmoi)"
  echo "🔄 Restarting zsh..."
  exec zsh
}

# Switch between tmux and zellij
switch-multiplexer() {
  local mux="${1:-}"
  local chezmoi_config_source="${HOME}/.local/share/chezmoi/.chezmoi.toml.tmpl"
  local chezmoi_config_rendered="${HOME}/.config/chezmoi/chezmoi.toml"

  if [[ -z "$mux" ]]; then
    # Show current configuration (read from rendered config)
    local current_mux=$(grep 'multiplexer' "$chezmoi_config_rendered" 2>/dev/null | command sed 's/.*"\(.*\)".*/\1/')
    echo "Current multiplexer: ${current_mux:-tmux}"
    echo ""
    echo "Usage: switch-multiplexer [tmux|zellij]"
    echo ""
    echo "Available multiplexers:"
    echo "  tmux     - Traditional terminal multiplexer (default)"
    echo "             Mature, stable, extensive ecosystem"
    echo "             Ctrl+g prefix (custom)"
    echo ""
    echo "  zellij   - Modern Rust-based multiplexer"
    echo "             Built-in UI, WebAssembly plugins"
    echo "             Ctrl+g prefix (matches tmux)"
    return 0
  fi

  if [[ "$mux" != "tmux" && "$mux" != "zellij" ]]; then
    echo "Error: multiplexer must be 'tmux' or 'zellij'" >&2
    return 1
  fi

  # Update .chezmoi.toml.tmpl (source file)
  if [[ ! -f "$chezmoi_config_source" ]]; then
    echo "Error: chezmoi config not found at $chezmoi_config_source" >&2
    return 1
  fi

  # Use sed to update the multiplexer value (use command to bypass alias)
  command sed -i '' "s/multiplexer = \".*\"/multiplexer = \"$mux\"/" "$chezmoi_config_source"

  echo "✅ Multiplexer switched to: $mux"
  echo "📝 Updated: ~/.local/share/chezmoi/.chezmoi.toml.tmpl"
  echo "🔄 Regenerating config..."

  # Regenerate config from template
  chezmoi init > /dev/null 2>&1

  echo "🔄 Applying terminal emulator configs..."

  # Apply terminal emulator configurations
  chezmoi apply ~/.config/alacritty/alacritty.toml > /dev/null 2>&1
  chezmoi apply ~/.config/kitty/kitty.conf > /dev/null 2>&1
  chezmoi apply ~/.config/ghostty/config > /dev/null 2>&1

  echo "💡 Restart your terminal emulator to use $mux"
  echo "   Or run: exec zsh"
}

# Switch between modular and monolithic zsh configuration
# Similar to LazyVim/AstroNvim or Starship/P10k switching
switch-zsh-config() {
  local variant="${1:-}"
  local chezmoi_config_source="${HOME}/.local/share/chezmoi/.chezmoi.toml.tmpl"
  local chezmoi_config_rendered="${HOME}/.config/chezmoi/chezmoi.toml"

  if [[ -z "$variant" ]]; then
    # Show current configuration (read from rendered config)
    local current_variant=$(grep -A1 '^\[data\.zsh\]' "$chezmoi_config_rendered" 2>/dev/null | grep 'variant' | command sed 's/.*"\(.*\)".*/\1/')
    echo "Current zsh configuration: ${current_variant:-modular}"
    echo ""
    echo "Usage: switch-zsh-config [modular|monolithic]"
    echo ""
    echo "Available variants:"
    echo "  modular     - Optimized multi-file config with deferred loading (default)"
    echo "                Performance: 48.7ms min, 55.1ms avg"
    echo "                Structure: ~/.config/zsh/conf.d/ (7 modules)"
    echo ""
    echo "  monolithic  - Traditional single-file config (legacy)"
    echo "                Performance: ~57ms baseline"
    echo "                Structure: Single ~/.zshrc file"
    return 0
  fi

  if [[ "$variant" != "modular" && "$variant" != "monolithic" ]]; then
    echo "Error: variant must be 'modular' or 'monolithic'" >&2
    return 1
  fi

  # Update .chezmoi.toml.tmpl (source file)
  if [[ ! -f "$chezmoi_config_source" ]]; then
    echo "Error: chezmoi config not found at $chezmoi_config_source" >&2
    return 1
  fi

  # Use sed to update the variant value (use command to bypass alias)
  command sed -i '' "s/variant = \".*\"/variant = \"$variant\"/" "$chezmoi_config_source"

  echo "✅ Zsh configuration switched to: $variant"
  echo "📝 Updated: ~/.local/share/chezmoi/.chezmoi.toml.tmpl"
  echo "🔄 Regenerating config..."

  # Regenerate config from template
  chezmoi init > /dev/null 2>&1

  echo "🔄 Applying changes..."

  # Apply changes
  chezmoi apply ~/.config/zsh/.zshrc > /dev/null 2>&1

  echo "🔄 Restarting zsh..."
  exec zsh
}

# ============================================================================
# Functions - Repository Management
# ============================================================================

# Repository navigation with fzf and multiplexer integration
repo() {
  local launch_mux=false
  local top_panes="${TOP_PANES:-1}"
  local repo_arg=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --tmux|-t|--mux|-m)
        launch_mux=true
        shift
        ;;
      -t2|-m2)
        launch_mux=true
        top_panes=2
        shift
        ;;
      --dual)
        top_panes=2
        shift
        ;;
      *)
        repo_arg="$1"
        shift
        ;;
    esac
  done

  local repo=""

  if [ -n "$repo_arg" ]; then
    local matched=$(ghq list | grep -i "$repo_arg" | head -1)
    if [ -n "$matched" ]; then
      repo="$matched"
    else
      echo "No repository matching '$repo_arg' found" >&2
      echo "Available repositories:" >&2
      ghq list | grep -i "$repo_arg" >&2
      return 1
    fi
  else
    repo=$(ghq list | fzf --preview "bat --color=always --style=header,grid $(ghq root)/{}/README.md 2>/dev/null || eza -al --tree --level=2 $(ghq root)/{}")
  fi

  if [ -n "$repo" ]; then
    local repo_path=$(ghq root)/$repo

    if [ "$launch_mux" = true ]; then
      local repo_name=$(basename "$repo")
      LEFT_DIR="$repo_path" TOP_PANES="$top_panes" mux-nvim "$repo_name"
    else
      cd "$repo_path"
    fi
  fi
}

# Clone repository with ghq
clone() {
  if [ -z "$1" ]; then
    echo "Usage: clone <repo-url>" >&2
    echo "Example: clone github.com/anthropics/claude-code" >&2
    return 1
  fi
  ghq get "$1" && cd $(ghq root)/$(ghq list | tail -1)
}

# Repository navigation with multiplexer nvim workspace
# Opens repository in mux-nvim workspace
mux-repo() {
  local repo_path=""
  local repo_name=""
  local top_panes="${TOP_PANES:-1}"
  local repo_arg=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dual|-2)
        top_panes=2
        shift
        ;;
      *)
        repo_arg="$1"
        shift
        ;;
    esac
  done

  if [ -n "$repo_arg" ]; then
    local matched=$(ghq list | grep -i "$repo_arg" | head -1)
    if [ -n "$matched" ]; then
      repo_path=$(ghq root)/$matched
      repo_name=$(basename "$matched")
    else
      echo "No repository matching '$repo_arg' found" >&2
      return 1
    fi
  else
    local current_path=$(pwd)
    local ghq_root=$(ghq root)

    if [[ "$current_path" == "$ghq_root"* ]]; then
      repo_path="$current_path"
      repo_name=$(basename "$current_path")
    else
      local repo=$(ghq list | fzf --preview "bat --color=always --style=header,grid $(ghq root)/{}/README.md 2>/dev/null || eza -al --tree --level=2 $(ghq root)/{}")
      if [ -n "$repo" ]; then
        repo_path=$(ghq root)/$repo
        repo_name=$(basename "$repo")
      else
        return 0
      fi
    fi
  fi

  if [ -n "$repo_path" ]; then
    LEFT_DIR="$repo_path" TOP_PANES="$top_panes" mux-nvim "$repo_name"
  fi
}

# Deprecated: use mux-repo instead
tmux-repo() {
  echo "Warning: tmux-repo is deprecated, use mux-repo instead" >&2
  mux-repo "$@"
}

# Repository statistics
ghq-stats() {
  echo "Total repositories: $(ghq list | wc -l | tr -d ' ')"
  echo "GitHub: $(ghq list | grep github.com | wc -l | tr -d ' ')"
  echo "GitLab: $(ghq list | grep gitlab.com | wc -l | tr -d ' ')"
  echo "Bitbucket: $(ghq list | grep bitbucket.org | wc -l | tr -d ' ')"
  echo ""
  echo "Most recently updated repositories:"
  ghq list --full-path | head -5 | while read repo_path; do
    local last_commit=$(git -C "$repo_path" log -1 --format='%ar' 2>/dev/null || echo "unknown")
    echo "  $(basename $repo_path): $last_commit"
  done
}

# ============================================================================
# Completions
# ============================================================================

_repo() {
  _arguments \
    '(-t --tmux -m --mux)'{-t,--tmux,-m,--mux}'[Launch mux-nvim with 1 pane]' \
    '(-t2 -m2)'{-t2,-m2}'[Launch mux-nvim with 2 panes]' \
    '--dual[Use 2 panes layout]' \
    '1:repository:_repo_list'
}

_repo_list() {
  local -a repos
  repos=(${(f)"$(ghq list 2>/dev/null)"})
  _describe -t repos 'ghq repositories' repos
}

_register_repo_completion() {
  if (( $+functions[compdef] )); then
    compdef _repo repo
    compdef _repo rt
    compdef _repo rt2
    compdef _repo rtd
  fi
}
zsh-defer _register_repo_completion

# ============================================================================
# Promptq Completions
# ============================================================================

_promptq() {
  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -C \
    '1: :->command' \
    '*:: :->args'

  case $state in
    command)
      local -a commands
      commands=(
        'add:Add prompt to queue'
        'list:List all queued prompts'
        'count:Show queue size'
        'send:Send first prompt (FIFO)'
        'select-send:Interactive send with fzf'
        'filter:Filter prompts by tag'
        'tags:List all tags with counts'
        'template:Template management'
        'snippet:Snippet management'
        'config:Configuration management'
        'clear:Clear all queued prompts'
        'clr:Clear all queued prompts (alias)'
        'help:Show help'
        'h:Show help (alias)'
        'version:Show version'
        'v:Show version (alias)'
      )
      _describe 'command' commands
      ;;

    args)
      case $words[1] in
        template)
          local -a template_commands
          template_commands=(
            'list:List available templates'
            'show:Show template content'
            'add:Add prompt from template'
          )
          _describe 'template command' template_commands
          ;;

        snippet)
          local -a snippet_commands
          snippet_commands=(
            'list:List available snippets'
            'show:Show snippet content'
            'add:Add prompt from snippet'
          )
          _describe 'snippet command' snippet_commands
          ;;

        config)
          local -a config_commands
          config_commands=(
            'set-pane:Set target tmux pane'
            'show-pane:Show current target pane'
          )
          _describe 'config command' config_commands
          ;;

        filter)
          # Complete with existing tags
          local -a tags
          if command -v promptq &>/dev/null; then
            tags=(${(f)"$(promptq tags 2>/dev/null | awk '{print $1}')"})
            _describe 'tag' tags
          fi
          ;;

        add)
          # For add command, allow free text input
          _message 'prompt text'
          ;;

        *)
          # No further completion
          ;;
      esac
      ;;
  esac
}

_register_promptq_completion() {
  if (( $+functions[compdef] )); then
    compdef _promptq promptq
    compdef _promptq ppq
  fi
}

# Register completion (deferred for performance)
zsh-defer _register_promptq_completion

# ============================================================================
# Performance Profiling (uncomment when benchmarking)
# ============================================================================
# zprof | head -40
