# ============================================================================
# Environment Variables
# Description: PATH configuration and development environment setup
# Dependencies: HOMEBREW_PREFIX (from 01-init.zsh)
# ============================================================================

# --- AI Profile (Claude Code / API Switching) ---
# Load current AI profile if exists (managed by claude-switch)
# set -a: auto-export all variables (required for child processes like Claude Code)
if [ -f "$HOME/.config/claude/.env" ]; then
  set -a
  source "$HOME/.config/claude/.env"
  set +a
fi

# --- Critical PATH (needed immediately) ---
# Empty for now - all PATHs can be deferred

# --- Helper function: Add to PATH only if not present ---
_add_to_path_prepend() {
  [[ ":$PATH:" != *":$1:"* ]] && export PATH="$1:$PATH"
}

_add_to_path_append() {
  [[ ":$PATH:" != *":$1:"* ]] && export PATH="$PATH:$1"
}

# --- Deferred PATH additions ---
# These development tools are rarely needed immediately at shell startup
_setup_dev_paths() {
  _add_to_path_prepend "{{ .chezmoi.homeDir }}/.slack/bin"
  # Cargo bin already added in .zshenv via '. "$HOME/.cargo/env"'
  _add_to_path_prepend "${HOMEBREW_PREFIX}/opt/gnu-time/libexec/gnubin"
  _add_to_path_prepend "${HOMEBREW_PREFIX}/opt/llvm/bin"

  # Alacritty custom scripts (toggle_opacity, etc.)
  _add_to_path_append "{{ .chezmoi.homeDir }}/.config/alacritty/bin"
}
zsh-defer _setup_dev_paths

# --- C++ Development (LLVM/Clang) ---
# Deferred to save ~2ms at startup - only loaded when needed
_setup_cpp_env() {
  export CC="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
  export CXX="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
  export SDKROOT="/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
  export CFLAGS="-isysroot ${SDKROOT}"
  export CXXFLAGS="-isysroot ${SDKROOT}"
  export LDFLAGS="-L${HOMEBREW_PREFIX}/opt/llvm/lib/c++ -Wl,-rpath,${HOMEBREW_PREFIX}/opt/llvm/lib/c++"
}
# Defer C++ environment setup - will be loaded after prompt
zsh-defer _setup_cpp_env

# ============================================================================
# Shell Management Functions (Critical - Must Load Immediately)
# ============================================================================
# These functions manage shell configuration and must be available immediately.
# They cannot be deferred because they're needed for interactive shell management.
# Dependencies: chezmoi, sed, tmux/zellij (optional)
# ============================================================================

# ============================================================================
# Multiplexer Abstraction Layer
# ============================================================================
# Detect current multiplexer from chezmoi config
# Returns: "tmux" or "zellij" (defaults to tmux)
get-multiplexer() {
  # Environment variable override
  if [[ -n "${MULTIPLEXER:-}" ]]; then
    echo "$MULTIPLEXER"
    return 0
  fi

  # Read from chezmoi config
  local chezmoi_config="${HOME}/.config/chezmoi/chezmoi.toml"
  if [[ -f "$chezmoi_config" ]]; then
    local mux=$(grep -A 1 '^\[data\.zsh\]' "$chezmoi_config" 2>/dev/null | \
                grep 'multiplexer' | \
                command sed 's/.*"\(.*\)".*/\1/')
    if [[ -n "$mux" ]]; then
      echo "$mux"
      return 0
    fi
  fi

  # Default to tmux
  echo "tmux"
}

# Check if running inside a multiplexer
in-multiplexer() {
  [[ -n "${TMUX:-}" || -n "${ZELLIJ:-}" ]]
}

# Get current multiplexer type (when inside one)
current-multiplexer() {
  if [[ -n "${TMUX:-}" ]]; then
    echo "tmux"
  elif [[ -n "${ZELLIJ:-}" ]]; then
    echo "zellij"
  else
    echo "none"
  fi
}

# Kill current window (abstracted)
mux-kill-window() {
  local mux=$(current-multiplexer)
  case "$mux" in
    tmux)
      local id
      id="$(tmux display -p '#{window_id}' 2>/dev/null)" || {
        echo "Run inside tmux session" >&2; return 1
      }
      tmux kill-window -t "$id"
      ;;
    zellij)
      zellij action close-tab
      ;;
    *)
      echo "Not inside a multiplexer session" >&2
      return 1
      ;;
  esac
}

# Note: twk is now an alias to mux-kill-window (see 05-aliases.zsh)

# Clear zsh caches and restart
zsh-refresh() {
  echo "Clearing sheldon cache..."
  command rm -f "${XDG_CACHE_HOME:-$HOME/.cache}/sheldon/sheldon.zsh"
  echo "Clearing completion cache..."
  command rm -f "${ZDOTDIR:-$HOME}/.zcompdump"
  echo "Restarting zsh..."
  exec zsh
}

# Switch between Starship and Powerlevel10k
switch-prompt() {
  local theme="${1:-}"
  local zshenv_local="${ZDOTDIR:-$HOME}/.zshenv.local"

  if [[ -z "$theme" ]]; then
    echo "Current prompt: $PROMPT_THEME"
    echo ""
    echo "Usage: switch-prompt [starship|p10k]"
    echo ""
    echo "Performance (zsh-bench):"
    echo "  P10k:     first_prompt=45.9ms, command=42.9ms  (faster)"
    echo "  Starship: first_prompt=83.5ms, command=83.8ms  (cross-shell)"
    return 0
  fi

  if [[ "$theme" != "starship" && "$theme" != "p10k" ]]; then
    echo "Error: theme must be 'starship' or 'p10k'" >&2
    return 1
  fi

  echo "# Prompt theme override (managed by switch-prompt command)" > "$zshenv_local"
  echo "export PROMPT_THEME=$theme" >> "$zshenv_local"

  echo "‚úÖ Prompt switched to: $theme"
  echo "üìù Saved to: ~/.zshenv.local (not in chezmoi)"
  echo "üîÑ Restarting zsh..."
  exec zsh
}

# Switch between modular and monolithic zsh configuration
# Similar to LazyVim/AstroNvim or Starship/P10k switching
switch-zsh-config() {
  local variant="${1:-}"
  local chezmoi_config_source="${HOME}/.local/share/chezmoi/.chezmoi.toml.tmpl"
  local chezmoi_config_rendered="${HOME}/.config/chezmoi/chezmoi.toml"

  if [[ -z "$variant" ]]; then
    # Show current configuration (read from rendered config)
    local current_variant=$(grep -A1 '^\[data\.zsh\]' "$chezmoi_config_rendered" 2>/dev/null | grep 'variant' | command sed 's/.*"\(.*\)".*/\1/')
    echo "Current zsh configuration: ${current_variant:-modular}"
    echo ""
    echo "Usage: switch-zsh-config [modular|monolithic]"
    echo ""
    echo "Available variants:"
    echo "  modular     - Optimized multi-file config with deferred loading (default)"
    echo "                Performance: 48.7ms min, 55.1ms avg"
    echo "                Structure: ~/.config/zsh/conf.d/ (7 modules)"
    echo ""
    echo "  monolithic  - Traditional single-file config (legacy)"
    echo "                Performance: ~57ms baseline"
    echo "                Structure: Single ~/.zshrc file"
    return 0
  fi

  if [[ "$variant" != "modular" && "$variant" != "monolithic" ]]; then
    echo "Error: variant must be 'modular' or 'monolithic'" >&2
    return 1
  fi

  # Update .chezmoi.toml.tmpl (source file)
  if [[ ! -f "$chezmoi_config_source" ]]; then
    echo "Error: chezmoi config not found at $chezmoi_config_source" >&2
    return 1
  fi

  # Use sed to update the variant value (use command to bypass alias)
  command sed -i '' "s/variant = \".*\"/variant = \"$variant\"/" "$chezmoi_config_source"

  echo "‚úÖ Zsh configuration switched to: $variant"
  echo "üìù Updated: ~/.local/share/chezmoi/.chezmoi.toml.tmpl"
  echo "üîÑ Regenerating config..."

  # Regenerate config from template
  chezmoi init > /dev/null 2>&1

  echo "üîÑ Applying changes..."

  # Apply changes
  chezmoi apply ~/.config/zsh/.zshrc > /dev/null 2>&1

  echo "üîÑ Restarting zsh..."
  exec zsh
}

# Switch between tmux and zellij
switch-multiplexer() {
  local mux="${1:-}"
  local chezmoi_config_source="${HOME}/.local/share/chezmoi/.chezmoi.toml.tmpl"
  local chezmoi_config_rendered="${HOME}/.config/chezmoi/chezmoi.toml"

  if [[ -z "$mux" ]]; then
    # Show current configuration (read from rendered config)
    local current_mux=$(grep 'multiplexer' "$chezmoi_config_rendered" 2>/dev/null | command sed 's/.*"\(.*\)".*/\1/')
    echo "Current multiplexer: ${current_mux:-tmux}"
    echo ""
    echo "Usage: switch-multiplexer [tmux|zellij]"
    echo ""
    echo "Available multiplexers:"
    echo "  tmux     - Traditional terminal multiplexer (default)"
    echo "             Mature, stable, extensive ecosystem"
    echo "             Ctrl+g prefix (custom)"
    echo ""
    echo "  zellij   - Modern Rust-based multiplexer"
    echo "             Built-in UI, WebAssembly plugins"
    echo "             Ctrl+g prefix (matches tmux)"
    return 0
  fi

  if [[ "$mux" != "tmux" && "$mux" != "zellij" ]]; then
    echo "Error: multiplexer must be 'tmux' or 'zellij'" >&2
    return 1
  fi

  # Update .chezmoi.toml.tmpl (source file)
  if [[ ! -f "$chezmoi_config_source" ]]; then
    echo "Error: chezmoi config not found at $chezmoi_config_source" >&2
    return 1
  fi

  # Use sed to update the multiplexer value (use command to bypass alias)
  command sed -i '' "s/multiplexer = \".*\"/multiplexer = \"$mux\"/" "$chezmoi_config_source"

  echo "‚úÖ Multiplexer switched to: $mux"
  echo "üìù Updated: ~/.local/share/chezmoi/.chezmoi.toml.tmpl"
  echo "üîÑ Regenerating config..."

  # Regenerate config from template
  chezmoi init > /dev/null 2>&1

  echo "üîÑ Applying terminal emulator configs..."

  # Apply terminal emulator configurations
  chezmoi apply ~/.config/alacritty/alacritty.toml > /dev/null 2>&1
  chezmoi apply ~/.config/kitty/kitty.conf > /dev/null 2>&1
  chezmoi apply ~/.config/ghostty/config > /dev/null 2>&1

  echo "üí° Restart your terminal emulator to use $mux"
  echo "   Or run: exec zsh"
}

# Switch between API and MAX authentication for Claude Code
# Avoids auth conflicts by logging out before switching to API mode
claude-switch() {
  local profile="${1:-}"
  local cfg="$HOME/.config/claude"

  if [ -z "$profile" ]; then
    echo "Usage: claude-switch [api|max]"
    echo ""
    echo "  api - Use Anthropic API Key (pay-per-use)"
    echo "  max - Use Claude Max/Pro subscription"
    return 1
  fi

  case "$profile" in
    api|API)
      # Check config exists
      if [ ! -f "$cfg/.env.api" ]; then
        echo "‚ùå $cfg/.env.api not found. Run: mise claude-init"
        return 1
      fi

      # Switch profile
      cp "$cfg/.env.api" "$cfg/.env"

      # Apply to current shell
      set -a
      source "$cfg/.env"
      set +a

      echo "‚úÖ Switched to API mode"
      echo "   üí≥ Usage will be charged to API key"
      echo "   Active in current shell and future shells"
      echo ""
      echo "üí° ANTHROPIC_API_KEY takes precedence over any logged-in account"
      ;;

    max|MAX)
      # Check config exists
      if [ ! -f "$cfg/.env.max" ]; then
        echo "‚ùå $cfg/.env.max not found. Run: chezmoi apply"
        return 1
      fi

      # Switch profile
      cp "$cfg/.env.max" "$cfg/.env"

      # Unset API key and apply to current shell
      unset ANTHROPIC_API_KEY
      set -a
      source "$cfg/.env"
      set +a

      echo "‚úÖ Switched to MAX mode"
      echo "   üé´ Usage will be charged to Max/Pro subscription"
      echo "   Active in current shell and future shells"
      ;;

    *)
      echo "‚ùå Unknown profile: $profile"
      echo "Usage: claude-switch [api|max]"
      return 1
      ;;
  esac
}

# Alias for checking current profile
alias claude-current='mise claude-current'

# Usage tracking aliases for MAX and API accounts
# ccusage: Aggregates historical data from both directories
alias ccusage='CLAUDE_CONFIG_DIR="{{ .chezmoi.homeDir }}/.claude,{{ .chezmoi.homeDir }}/.claude-personal" command ccusage'

# claude-monitor: Points to latest session data in ~/.claude-personal
# Note: claude-code-monitor doesn't support multiple directories (unlike ccusage),
#       so we explicitly point to where the latest sessions are stored
alias claude-monitor='CLAUDE_CONFIG_DIR="{{ .chezmoi.homeDir }}/.claude-personal" command claude-code-monitor'

# ============================================================================
# Codex Profile Management
# ============================================================================
# Load Codex profile if exists
if [ -f "$HOME/.config/codex/.env" ]; then
  set -a
  source "$HOME/.config/codex/.env"
  set +a
fi

# Switch between API and subscription for Codex
codex-switch() {
  local profile="${1:-}"
  local cfg="$HOME/.config/codex"

  if [ -z "$profile" ]; then
    echo "Usage: codex-switch [api|max]"
    echo ""
    echo "  api - Use OpenAI API Key (pay-per-use)"
    echo "  max - Use ChatGPT subscription (Plus/Pro)"
    return 1
  fi

  case "$profile" in
    api|API)
      # Check config exists
      if [ ! -f "$cfg/.env.api" ]; then
        echo "‚ùå $cfg/.env.api not found. Run: mise codex-init"
        return 1
      fi

      # Switch profile
      cp "$cfg/.env.api" "$cfg/.env"

      # Apply to current shell
      set -a
      source "$cfg/.env"
      set +a

      echo "‚úÖ Switched to API mode"
      echo "   üí≥ Usage will be charged to API key"
      echo "   Active in current shell and future shells"
      echo ""

      # Perform login
      if [ -n "${OPENAI_API_KEY:-}" ]; then
        echo "üîê Logging in with API key..."
        if printf "%s" "$OPENAI_API_KEY" | mise exec -- codex login --with-api-key 2>&1; then
          echo "‚úÖ Logged in successfully"
        else
          echo "‚ö†Ô∏è  Login failed"
        fi
      fi

      echo ""
      echo "üí° OPENAI_API_KEY + CODEX_HOME=$CODEX_HOME"
      ;;

    max|MAX)
      # Check config exists
      if [ ! -f "$cfg/.env.max" ]; then
        echo "‚ùå $cfg/.env.max not found. Run: chezmoi apply"
        return 1
      fi

      # Switch profile
      cp "$cfg/.env.max" "$cfg/.env"

      # Unset API key and apply to current shell
      unset OPENAI_API_KEY
      set -a
      source "$cfg/.env"
      set +a

      echo "‚úÖ Switched to subscription mode"
      echo "   üé´ Usage will be charged to ChatGPT subscription"
      echo "   Active in current shell and future shells"
      echo ""
      echo "üí° CODEX_HOME=$CODEX_HOME"
      ;;

    *)
      echo "‚ùå Unknown profile: $profile"
      echo "Usage: codex-switch [api|max]"
      return 1
      ;;
  esac
}

# Alias for checking current Codex profile
alias codex-current='mise codex-current'

# ============================================================================
# GitHub Integration (1Password)
# ============================================================================
# Fallback pattern: env variable ‚Üí chezmoi data ‚Üí 1Password
# GITHUB_TOKEN is used by: gh CLI, git, chezmoi GitHub functions, GitHub Copilot CLI
{{- if or (env "GITHUB_TOKEN") .github_token }}
export GITHUB_TOKEN="{{ or (env "GITHUB_TOKEN") .github_token }}"
{{- end }}
